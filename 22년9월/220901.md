# 📖 오늘의 학습

## 타이머

> 함수는 호출하면 즉시 실행한다. 함수를 일정 시간 경과 후 호출되도록 하려명 타이머 함수를 사용해야 한다. 이를 호출 스케줄링이라고 한다. 타이머 함수는 호스트 객체이고 자바스크립트는 싱글 스레드로 동작하기 때문에 타이머 함수는 비동기 처리 방식으로 동작한다.

### 타이머 함수

- setTimeout / clearTimeout
  첫 번째 인수는 콜백 함수나 코드가 들어갈 수 있다. 코드는 eval처럼 동작하기 때문에 사용하지 않는게 좋다.
  두 번째 인수로 준 시간을 가지고 타이머를 생성하며 만료 후 콜백 함수를 단 한 번 실행한다.
  이후 인수로 전달된 값은 콜백 함수의 인수로 전달된다.
  setTimeout 함수는 타이머를 식별할 수 있는 고유한 타이머 id를 반환한다.
  이 id를 가지고 등록해놓은 호출 스케줄링을 취소할 수 있다.
- setInterval / clearInterval
  두 번째 전달받은 인수의 시간으로 반복 동작하는 타이머를 생성한다.
  타이머가 완료될 때마다 인수로 전달받은 콜백 함수가 반복 호출된다.
  고유한 타이머 id를 반환하며 이를 통해 타이머를 취소하기 전까지 계속 반복한다.

### 디바운스와 스로틀

> 짧은 시간동안 연속적으로 발생하는 이벤트는 이벤트 핸들러 등록 시 과도하게 호출되어 성능에 문제를 일으킬 수 있다. 디바운스와 스로틀은 연속적인 이벤트를 그룹화하여 과도한 이벤트 핸들러 호출을 방지하는 프로그래밍 기법이다.

- 디바운스
  연속적으로 이벤트가 발생하면 이벤트 핸들러를 호출하지 않다가 일정 시간이 경과한 후에 이벤트 핸들러가 한번만 호출되도록 한다. input같이 입력이 완료되기 전에 매번 요청이 반복되면 불필요한 처리이므로 입력이 완료된 후 한번만 요청하는 것이 바람직하다. 이럴 때 디바운스 함수를 사용하여 클로저를 활용해 타이머가 이미 존재하는 경우 그 타이머를 취소하고 새로 등록하여 마지막으로 발생한 이벤트의 지연 시간 이후 호출한다.
- 스로틀
  연속적으로 이벤트가 발생하더라도 일정 시간 간격으로만 호출되도록 한다. 스로틀은 이벤트를 그룹화하여 일정 시간 단위로 이벤트 핸들러가 호출되도록 호출 주기를 만든다. 주로 scroll 이벤트 처리에 사용된다.

두 기법 모두 라이브러리에서 제공되는 함수를 사용하길 권장한다.

## 비동기 프로그래밍

### 동기 처리와 비동기 처리

> 자바스크립트는 단 하나의 실행 컨텍스트 스택을 가진다. 콜 스택이라고도 부르고 싱글 스레드로 동작하기 때문에 실행 중인 실행 컨텍스트를 제외한 모든 실행 컨텍스트는 대기 중인 태스크이다. 때문에 처리에 시간이 걸리는 태스크를 실행하는 경우 블로킹이 발생한다. 이처럼 동작하는 것을 동기 처리라고 한다. setTimeout 처럼 블로킹이 발생하지 않고 다음 태스크를 바로 실행하는 방식을 비동기 처리라고 한다. 비동기 처리는 실행 순서가 보장되지 않는다는 단점이 있다. 타이머 함수, HTTP 요청, 이벤트 핸들러는 비동기 처리 방식으로 동작한다.

### 이벤트 루프와 테스크 큐

> 자바스크립트는 싱글 스레드로 동작하지만 동시에 처리되는 것처럼 느껴지는 것들도 있다. 이처럼 자바스크립트의 동시성을 지원하는 것이 바로 이벤트 루프다. 이벤트 루프는 브라우저에 내장되어 있는 기능 중 하나이고 콜 스택과 태스크 큐를 항상 감시하고 있다.

- 태스크 큐는 비동기 함수의 콜백 함수 또는 이벤트 핸들러가 잠시 보관되는 영역이다.
- 이벤트 루프는 콜 스택이 비어있는지 확인 후 태스크 큐에 대기 중인 함수가 있다면 순차적으로 이동시킨다.

## Ajax

### Ajax란?

> 자바스크립트를 사용하여 브라우저가 서버에게 비동기 방식으로 데이터를 요청하고 응답한 데이터를 수신하여 웹페이지를 동적으로 갱신하는 프로그래밍 방식을 말한다. 전통적인 방식의 웹페이지는 완전한 HTML을 전송받아 웹페이지 전체를 다시 렌더링하는 방식으로 동작했다. 때문에 다시 그리지 않아도 되는 부분까지 처음부터 렌더링하여 화면이 깜빡이는 현상이 발생하고, HTML을 매번 서버로부터 전송받기 때문에 불필요한 데이터 통신이 발생한다. Ajax는 필요한 데이터만 전송받아 불필요한 데이터 통신을 발생시키지 않고, 필요한 부분만 다시 렌더링하며 서버와의 통신이 비동기 방식으로 동작하기 때문에 블로킹이 발생하지 않는다.

### JSON

> JSON은 HTTP 통신을 위한 데이터 포멧이다. 대부분의 프로그래밍 언어에서 사용할 수 있다. 객체 리터럴과 유사하게 key와 value로 구성된 순수한 텍스트이다.

- JSON.stringify는 객체(배열)를 JSON 포맷의 문자열로 반환한다. 서버에 전달을 위한 직렬화
- JSON.parse는 JSON 포맷의 문자열을 객체(배열)로 변환한다. 클라이언트에서 사용하기 위한 역직렬화

### XMLHttpRequest

> 자바스크립트는 HTTP 요청을 전송하려면 XMLHttpRequest 객체를 사용한다. HTTP 요청 전송과 응답 수신을 위한 다양한 메서드와 프로퍼티를 제공한다.

## REST API

> REST는 HTTP를 기반으로 클라이언트가 서버의 리소스에 접근하는 방식을 규정한 아키텍처이다. REST API는 이 규정을 준수하여 기반한 API를 말한다. 자원 , 행위, 표현의 3가지 요소로 구성되며 REST API만으로 HTTP 요청을 이해할 수 있어야 한다. 가장 기본적인 두 가지 원칙은 URI는 리소스를 표현하는 데 집중하고 행위에 대한 정의는 HTTP 요청 메서드가 하는 것이다.

# 💥 수업 정리

- 브라우저에 포함되어 있는 이벤트 루프가 태스크 큐에 대기중인 함수를 콜 스택으로 전달하는 행위가 호출
- 타이머 함수는 딜레이 시간만큼을 샌 후 호출해주세요 라고 브라우저에게 요청하고 바로 팝 된다.
- 브라우저가 시간을 다 재면 틱 이벤트가 발생하여 콜백 함수가 태스크 큐에 넣어준다.
- 자바스크립트가 싱글 스레드가 아니고 콜 스택이 한개여서 엔진이 싱글 스레드이다.
- 에크마 + 웹 API 를 포함하는 것이 자바스크립트이므로 자바스크립트가 싱글 스레드인 것은 아니다.
- 멀티 스레드일 경우 순서를 예측하기 어려우므로 어렵다.
- 엔진의 싱글 스레드 블로킹 문제를 해결하기 위해 이벤트 루프와 테스크 큐가 존재
- 싱글 스레드지만 동시성을 놓칠 수 없었기 때문에 비동기를 사용한다.
- 비동기는 주로 서버와의 통신에 제일 많이 사용된다.
- 브라우저가 클라이언트, 그리기 위한 리소스를 서버에게서 받아오는 통신 규약이 HTTP
- 중구난방으로 요청을 보낼 수 없으니 규약을 정한 것이 REST API
- URI로 행위 메서드로 표현을 하여 이 것만으로 이해할 수 있어야 한다. REST는 컨벤션
- 요청과 응답은 항상 쌍으로 이루어진다.
- 서버는 아스키코드로 변환하여 넘겨준다. 객체 포맷을 주고받기 위해 JSON 메서드 사용
- JSON이 생기기 전에는 XML을 사용했기 떄문에 XMLHttpRequest 라는 이름
- XML은 태그와 어트리뷰트가 존재하여 상당히 큰 비용이 발생, 배보다 배꼽ㅋ
- CORS에 대해 정리해볼 것
- 400번대 status는 요청 상 오류, 500번대는 서버의 오류
- 리턴값은 콜러가 받을 수 있다. 즉 호출하지 않으면 못받는다!
- 비동기를 동기처럼 사용하기 위한 긴 여정이 시작된다.
- 프로미스는 상태를 가진 객체이다. status와 value 내부슬롯을 가진다.
- new promise((resolve,reject) ⇒ {비동기 로직});
- 생성자함수가 콜백을 호출하고 콜백 함수 두개를 넣어준다.
- then이 하는 역할은 동기 함수이고 프로미스 객체의 상태가 변했을 때 콜백 함수를 호출해달라고 비동기 처리
- resolve의 인수로 전달한 값을 받아온다.
- catch는 reject의 인수를 받아온다. new error를 사용할 것
- then catch 를 사용하지 말고 async await를 사용하는 것이 좋다.
- top level await가 제안되어 있고 크롬에 구현되어 있다.
- 에러 처리는 상당히 중요하다. 에러가 발생한 지점에서 에러 처리를 할 것인지 top level 즉 상위 컨텍스트에서 처리할 것 인지 정해야 하는데 발생 지점에서 하는 경우 에러를 매번 다 써줘야한다. 그렇기 때문에 탑 레벨에서 하는 경우가 흔하다. 에러는 콜러로 전파가 된다. 직접 호출하지 않은 경우 에러가 전파되지 않는다.
- 동기처럼, 리턴을 받을 수 있게 되면서 async await 에서 try catch를 사용할 수 있게 되었다.

# 🤯 하루을 마치며…

오늘은 비동기에 대한 내용에 대해 러버덕을 진행하였다. 어제 학습한 내용들의 연장선으로 프로미스와 제너레이터, async await를 사용한 비동기 처리 방법에 대해 공부하였는데, 표면적으로 사용법에 대한 내용으로만 보았을 때는 어떻게 써야하는지 따라갈 수 있지만 동작 과정에 대한 이해를 하려고 생각하니 매우 어려웠다. 비동기를 마치 동기처럼 사용할 수 있게 해주고 에러 처리까지 가능한 async await를 이해하기 위해서는 아무래도 직접 코드에 적용해보는 것이 필요할 것 같다. 내일이면 책이 마무리되고 실습을 하게 되는데 최대한 책에서 습득한 지식들을 떠올리고 코드에 녹여내기 위해 연습을 많이 해봐야겠다!
