# 📖 딥다이브 러버덕 복습

## 리터럴로 생성된 객체의 프로토타입

### Array 리터럴

![스크린샷 2022-08-17 오후 9.15.10.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/9766173b-98b8-43b6-b6da-fef0c2e3ab02/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2022-08-17_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_9.15.10.png)

리터럴이 내부 동작에 의해 평가되면 1번 ArrayCreate() 실행

![스크린샷 2022-08-17 오후 9.26.30.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/2e657c0f-fa33-4ffe-a793-fe5199dc6653/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2022-08-17_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_9.26.30.png)

ArrayCreate() 내부 4번 → 8번 Array.prototype 연결해줌

모든 과정 실행 후 배열 객체를 반환해준다.

### 정규표현식 리터럴

![스크린샷 2022-08-17 오후 9.13.52.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/61c50ed4-2c99-4831-96dc-46dd0f88d5ee/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2022-08-17_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_9.13.52.png)

3번 RegExpCreate() 실행

![스크린샷 2022-08-17 오후 9.27.44.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/c3b41afd-c44c-48f7-a882-4176ae142087/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2022-08-17_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_9.27.44.png)

1번 RegRxpAlloc() 실행

![스크린샷 2022-08-17 오후 9.27.58.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/03f349a4-7610-4cdd-9851-9a48e672c857/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2022-08-17_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_9.27.58.png)

1번에서 프로토타입 연결해줌

모든 과정 실행 후 정규표현식 객체 반환해준다.

### 함수 리터럴

함수 리터럴은 배열이나 정규표현식과 다르게 리터럴 파트에 명시되어 있지 않아 고민을 해본 결과

표현식이 함수를 리터럴로 만드는 것이기 때문에 표현식 부분을 확인해 보았다.

![스크린샷 2022-08-17 오후 9.24.42.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/e8806301-817e-4ef0-acb7-1c6525b36ae4/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2022-08-17_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_9.24.42.png)

익명함수 표현식 3번과 기명함수 표현식 7번의 FunctionCreate()가 동작하여

![스크린샷 2022-08-17 오후 9.44.41.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/27e48ff6-3f9c-43d8-b21c-a40e5bb20183/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2022-08-17_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_9.44.41.png)

1번 → 4번 프로토타입을 연결한다.

## strict mode

> 문법을 엄격하게 적용하는 모드로 잠재적인 오류들을 예방하게 해준다.

ESLint는 오류는 물론 코딩 컨벤션 설정을 파일 형태로 정의할 수 있어 더욱 강력한 효과를 얻을 수 있다.

### strict mode의 적용

- 전역의 선두 또는 함수의 선두에 ‘use strict’;를 추가한다.
- 전역의 선두에 선언하면 스크립트 전체에 적용된다.

### 전역에 strict mode를 적용하는 것은 피하자

- 전역에 지정하면 스크립트 단위로 적용되어 다른 스크립트에 영향을 주지 않는다.
- strict mode와 non-strict mode 스크립트를 혼용하는 것은 오류를 야기한다.
- 스크립트 전체를 감싼 즉시 실행 함수의 선두에 선언하는 것이 좋다.

### 함수 단위로 strict mode를 적용하는 것도 피하자

- 함수마다 strict mode 적용이 각각이라면 바람직하지 않다.
- 모든 함수에 일일이 적용하는 것은 번거로운 일이다.

### strict mode가 발생시키는 에러

- 암묵적 전역
- delete 연산자로 변수, 함수, 매개변수 삭제 시 에러
- 매개변수의 이름 중복
- with문의 사용 ( 성능과 가독성의 문제, 사용 x )

### strict mode 적용에 의한 변화

- 일반 함수의 this에는 undefined가 바인딩된다.
- 매개변수에 값을 재할당 하여도 arguments 객체에 반영되지 않는다.

## \_빌트인 객체

### 자바스크립트 객체의 분류

- 표준 빌트인 객체
- 호스트 객체
- 사용자 정의 객체

### 표준 빌트인 객체

Math, Reflect, JSON을 제외한 모든 빌트인 객체는 인스턴스를 생성할 수 있는 생성자 함수이다.

new 키워드와 함께 인스턴스를 생성하면 해당 생성자 함수의 prototype을 상속받는 인스턴스가 생성된다.

### 원시값과 래퍼 객체

문자열, 숫자, 불리언 원시값에 대해 객체처럼 접근하면 임시로 래퍼 객체가 생성된다.

null과 undefined는 래퍼 객체를 생성하지 않는다.

### 전역 객체

> 런타임 이전에 엔진에 의해 생성되는 최상위 객체이다.

# 💥 페어 프로그래밍

### 10. Carousel **slider**

이미지들을 활용하여 캐러셀을 만드는 미션을 수행했다. 요구사항만 보았을 때는 크게 어려운 것은 없다고 생각했는데 생각보다 구현하는 것이 까다로웠고, 무한 슬라이더를 구현하는 부분에서 인덱스를 바꿔줄 때에 대한 비동기처리에서 상당히 애를 먹었다. setTimeOut의 딜레이 시간까지 생각해서 동작을 지정했을 때 정상적으로 돌아갔다. 시간이 오래걸리고 애를 먹어서 그런지 완성되고 원하는대로 동작하는 것을 보고 매우 만족했다. 아직 리펙토링으로 수정해야할 부분들이 많이 있지만 구현을 완성했으니 차근차근 수정하여 완성도를 높여야겠다.
