# 📖 딥다이브 복습 러버덕

## 스코프

### 스코프란?

> 모든 식별자는 자신이 선언된 위치에 의해 다른 코드가 식별자 자신을 참조할 수 있는 유효 범위가 결정된다. 이를 스코프라 한다. 즉, 스코프는 식별자가 유효한 범위를 말한다.

자바스크립트는 스코프를 통해 어떤 변수를 참조해야 할지 결정한다. 이를 **식별자 결정**이라고 한다.

### 스코프의 종류

- 전역과 전역 스코프
  - 전역은 코드의 가장 바깥 영역을 말한다.
  - 전역에 변수를 선언하면 전역 스코프를 갖는다. 전역 변수는 어디든 참조할 수 있다.
- 지역과 지역 스코프
  - 지역이란 함수 몸체 내부를 말한다.
  - 지역 변수는 자신의 지역 스코프와 하위 지역 스코프에서 유효하다.

### 스코프 체인

> 함수는 중첩 될 수 있으므로 지역 스코프도 중첩될 수 있다. 스코프가 함수의 중첩에 의해 계층적 구조를 갖는다는 것을 의미한다.

변수를 참조할 때 자바스크립트 엔진은 스코프 체인을 통해 변수를 참조하는 코드의 스코프에서 시작하여 상위 스코프 방향으로 이동하여 선언된 변수를 검색한다.

### 함수 레벨 스코프

var 키워드는 오로지 함수의 코드 블록만을 지역 스코프로 인정한다. 이 특성을 함수 레벨 스코프라고 함

### 렉시컬 스코프

> 함수 정의가 평가되는 시점에 상위 스코프가 정적으로 결정, 정적 스코프 렉시컬 스코프라고 한다.

함수를 어디서 정의했는지에 따라 상위 스코프를 결정한다. 호출 된 위치는 상위 스코프 결정에 어떠한 영향도 주지 않는다. 따라서 함수의 상위 스코프는 언제나 자신이 정의된 스코프다.

## 전역 변수의 문제점

### 변수의 생명 주기

- 지역 변수의 생명 주기는 함수의 생명 주기와 일치한다.
- 누군가가 메모리 공간을 참조하고 있으면 해제되지 않고 확보된 상태로 남아있게 된다.
- 호이스팅은 스코프 단위로 동작한다.
- 함수와 달리 전역 코드는 호출 없이 실행되므로 전역 변수의 생명 주기는 전역 객체의 생명 주기와 일치한다.

### 전역 변수의 문제점

- 전역 변수를 선언한 의도는 어디서든 참조하고 할당할 수 있는 변수를 사용하겠다는 것이다. 이는 모든 코드가 전역 변수를 참조하고 변경할 수 있는 암묵적 결합을 허용하는 것이다.
- 전역 변수는 생명 주기가 일어 메모리 리소스도 오랜 기간 소비한다.
- 스코프 체인 상 종점에 존재하여 검색 속도가 가장 느리다.
- 다른 파일 내 동일한 이름의 전역 변수나 함수는 예상치 못한 결과를 가져올 수 있다.

### 전역 변수의 사용을 억제하는 방법

> 전역 변수를 반드시 사용해야 할 이유를 찾지 못했다면 지역 변수를 사용해야 한다.

- 즉시 실행 함수로 모든 코드를 감싸면 모든 변수는 즉시 실행 함수의 지역 변수가 된다.
- 전역에 네임스페이스 역할을 담당할 객체를 생성하는 방법, 객체 자체가 전역 변수에 할당되므로 그다지 유용하지는 않다.
- 모듈 패턴을 이용해 전역 변수의 억제는 물론 캡슐화까지 구현할 수 있다. 자바스크립트는 접근 제한자를 제공하지 않아 모듈 패턴을 사용해 전역 네임스페이스의 오염을 막음과 동시에 한정적이지만 정보 은닉을 구현하기 위해 사용된다.
- ES6 모듈을 사용하면 전역변수를 사용할 수 없다. 파일 자체의 독자적인 모듈 스코프를 제공한다.

## let, const 키워드와 블록 레벨 스코프

- var 키워드로 선언한 변수의 문제점은 중복 선언의 오류가 발생하지 않고, 함수 레벨 스코프이므로 의도치 않은 변화가 생길 수 있으며 변수의 호이스팅이 발생하여 가독성을 떨어트리고 오류의 여지를 준다.

### let 키워드

- 중복 선언에 대한 에러를 발생시킨다.
- 모든 코드 블록을 지역 스코프로 인정하는 블록 레벨 스코프를 따른다.
- let 키워드로 선언한 변수는 선언과 초기화가 분리되어 진행된다. 초기화가 이루어지기 전에 변수에 접근하려고 하면 참조 에러가 발생한다. 스코프의 시작 지점부터 초기화 시점까지를 일시적 사각지대(TDZ)라고 부른다. (호이스팅은 발생하지만 발생하지 않는 것 처럼 동작한다.)
- let 키워드로 선언한 변수는 전역 객체의 프로퍼티가 아니다. 전역 렉시컬 환경의 선언적 환경 레코드내에 존재하게 된다.

### const 키워드

- let과 대부분의 특징이 동일하다.
- 선언과 초기화가 동시에 이루어져야 한다.
- 재할당이 금지된다.
- 원시 값을 할당할 경우 값을 변경할 수 없기 때문에 상수를 표현하는데 사용하기도 한다.
- 상수는 재할당이 금지된 변수를 말한다.
- const 키워드로 선언한 변수에 객체를 할당할 경우 값을 변경할 수 있다.
- const 키워드는 재할당을 금지할 뿐 “불변”을 의미하지는 않는다.

# 💥 수업 정리

- HTML은 선언형 언어이므로 자바스크립트보다 이해하기 쉽다.
- 선언형은 무엇을(what)에 관심, 명령형은 (how)에 관심
- 명령형은 절차를 하나하나 나열, 기계에 가까움
- 선언형은 인간의 언어에 조금 더 가까움
- 컴포넌트 단위(HTML/CSS/JS를 하나로 묶어 생각한다)로 SPA를 구현
- 컴포넌트의 의미는 부품으로서 재사용되는 의미를 가지고 있다.
- 컴포넌트 기반은 커스텀 태그를 만들 수 있는 방법을 제공해야 한다.
- MVC는 컴포넌트와 전혀 관련이 없다.
- 모듈화는 결합도(상호 의존 정도)를 낮을수록, 응집도(기능적인 집중 정도)는 높을수록 이상적이다.
- 하나의 방법에 묶이지 말고 다양한 방법을 연습하는 것이 중요하다.
- 문제를 마주했을 때 적절한 방식은 무엇인지를 떠올릴 수 있는 것이 중요하다.
- 기존의 돔 기반은 노드를 가지고 오는 것에서부터 시작이기 때문에 의존도가 높아 사용하지 않는다.
- 이벤트 핸들러를 사용하지 않기 위해 어트리뷰트로 이벤트를 지정하는 방법
- 웹 서버와 어플리케이션 서버를 분리하여 ~~
- 웹 서버만으로 정적 페이지를 만들기 충분하다.
- 버전 0.0.0 메이저,마이너,패치(버그) 순 셈버 버저닝
- node 환경에서는 아직 import, export가 완전히 지원되지 않으므로 기존 방법 사용할 것

```html
const express = require('express'); // node-modules 애들은 경로 x
```

- 모든 상태가 서버에 가고 받아오는 것이 아니다. 서버에 갈 필요 없는 애는 로컬 스토리지 등을 활용할 것
- 서버에 있는 상태는 서버 상태라고 부르고 클라이언트에서 존재하는 상태와는 다르게 관리되어야 한다.
- 서버와 클라이언트가 동기화되어야 하는 상태를 서버 상태로 만든다.
- 캐싱을 하여 동기화하는 타이밍을 정하는 것 연구 대상임 ㅋㅅㅋ
