# 📖 딥다이브 복습 러버덕

## Date

> 표준 빌트인 객체인 date는 날짜와 시간을 위한 메서드를 제공하는 빌트인 객체면서 생성자 함수이다.

- UTC (협정 세계시)는 국제 표준시를 말함, GMT(그리니치 평균시)와 소수점 단위정도의 차이이므로 혼용하여 사용하기도 한다. KST (한국 표준시)는 UTC에 9시간을 더한 시간이다.
- 현재 날짜와 시간은 자바스크립트 코드가 실행된 시스템의 시계에 의해 결정된다!

### Date 생성자 함수

- 인수에 따라 4가지 생성 방식을 제공한다. 생성자 함수로 생성한 객체는 시간과 날짜를 나타내는 정수값을 가진다.

### Date 메서드

- 책과 mdn을 통해 Date 객체가 제공하는 메서드들을 확인해보기!

---

## RegExp

> 정규 표현식은 일정한 패턴을 가진 문자열의 집합을 표현하기 위해 사용하는 형식 언어이다. 자바스크립트의 고유 문법이 아니며, 대부분의 프로그래밍 언어와 코드 에디터에 내장되어 있다. 문자열을 대상으로 패턴 매칭 기능을 제공한다.

### 정규 표현식의 생성

- 정규 표현식은 리터럴과 생성자 함수로 생성할 수 있다. 일반적으로 리터럴로 만든다.

```jsx
// 리터럴
const regexp1 = /패턴/gi(플래그);
//생성자 함수
const regexp2 = new RegExp('패턴' or /패턴/,'플래그');
```

---

## String

> 표준 빌트인 객체 String은 원시 타입인 문자열을 다룰 때 유용한 프로퍼티와 메서드를 제공한다.

### String 생성자 함수

- new 연산자와 함께 호출하면 [[StringData]] 내부 슬롯에 빈 문자열을 할당한 레퍼 객체를 생성한다.
- 이렇게 만들어진 래퍼 객체는 유사 배열 객체이면서 이터러블 객체이다.
- 배열과 마찬가지로 length 프로퍼티를 가진다.

### String 메서드

> 문자열은 변경 불가능한 원시 값이기 때문에 String 래퍼 객체도 읽기 전용 객체로 제공, 메서드가 반환해주는 값은 언제나 새로운 문자열이다.

다양한 빌트인 메서드들은 책을 통해 알아보자!

---

## 7번째 타입 symbol

> ES6에서 도입된 7번째 데이터 타입으로 변경 불가능한 원시 타입 값이다. 다른 값과 중복되지 않는 유일무이한 값으로 주로 충돌 위험이 없는 유일한 프로퍼티 키를 만들기 위해 사용한다.

### symbol 함수

- 심벌 값은 함수를 통해서만 생성할 수 있으며 값이 외부로 노출되지 않는다. 따라서 값을 확인할 수 없으며 다른 값과 중복되지 않는 유일무이한 값이다.
- new 키워드와 함께 호출하면 에러가 발생한다. 함수에 선택적으로 문자열을 인수로 줄 수 있지만 생성된 symbol 값에 어떠한 영향도 주지 않는다. 이 문자열은 심벌 값에 대한 설명으로 디버깅 용도로만 사용된다.

### Symbol.for() / Symbol.keyfor() 메서드

- for() 메서드는 인수로 전달받은 문자열을 key로 사용하여 전역 심벌 레지스트리에서 검색하여 존재하지 않는 경우 key : symbolvalue 형태로 저장하고, 이미 존재한다면 해당 key의 심볼 값을 반환해준다.
- keyfor() 메서드는 전역 심벌 레지스트리에 저장된 심벌 값의 key를 추출할 수 있다.

# 💥 페어 프로그래밍

- darkMode
  함수 내부의 조건문을 null 병합 연산자 ?? 를 이용하여 복잡성을 제거하고 가독성을 높였다.
- autoComplete
  showSuggestList의 내부 로직에서 검색 조건에 대한 필터링까지 처리하고 그려내는 것을 분리해내어 getSuggestList 함수를 만들었고, 즉시실행 함수의 반환 객체 내부 함수 정의 방식을 하나로 통일시켜 전체적인 흐름을 맞추었다.
- formValidation
  기능 단위로 모듈을 분리하는 것에 대한 방향성을 잡는 것이 상당히 어려워 진전이 없었지만 경현님의 아이디어를 통해 해결의 실마리르 얻어 방향을 잡고 진행해보았다. auth 내부의 복잡하고 중복된 로직을 분리해내고, form의 이벤트 등록을 간소화하여 가독성을 높였다. 아직도 모듈을 분리하는 기준이 명확하지 않아 나만의 기준을 정하는 것이 어렵지만 코드에 정답이 없는 만큼 좋은 코드에 대한 누구나 납득할 수 있는 나만의 기준을 정하고 지키며 작성해야겠다.
