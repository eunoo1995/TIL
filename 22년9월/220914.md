# 📖 오늘의 학습

## 프로토타입

### 객체 지향 프로그래밍

> 절차 지향적인 관점에서 벗어나 객체의 집합으로 프로그래밍 하는 것

실체를 인식하는 사고를 프로그래밍에 접목한다. 실체는 특징이나 성질을 나타내는 **속성**을 가지고 있고 이를 통해 인식하거나 구별할 수 있다. 사람이라는 실체의 나이 몸무게 키 이름 등 다양한 속성들 중 나이와 이름만 가지고 사람을 구현하려고 추려내어 표현하는 것을 **추상화**라고 한다.

객체는 상태를 나타내는 프로퍼티와 동작을 나타내는 메서드를 모아놓은 복합적인 자료구조이다.

### 상속과 프로토타입

> 상속은 객체 지향의 핵심, 프로토타입 기반으로 상속을 구현하여 불필요한 중복 제거 가능

생성자 함수를 통해 인스턴스를 생성할 때 일반적으로 값을 저장하는 프로퍼티의 경우 인스턴스마다 다른 값을 가진다. 하지만 메서드의 경우 모든 인스턴스가 같은 메서드를 사용하므로 생성자 내부에 메서드를 만들 경우 매번 인스턴스가 생길 때 마다 중복된 메서드를 가지게 된다. 이런 불필요한 메모리의 낭비와 함수 생성 과정을 방지하기 위해 프로토타입을 통한 상속을 구현한다.

### 프로토타입 객체

> 어떤 객체의 상위(부모) 역할을 하는 객체로서 공유 프로퍼티를 제공한다.

모든 객체는 하나의 프로토타입을 갖고, 생성자 함수와 연결되어 있다.

- \***\*proto** 접근자 프로퍼티**
  모든 객체는 **proto**를 사용해 자신의 프로토타입에 간접적으로 접근할 수 있다.
  객체가 직접 소유하는 프로퍼티가 아닌 Object.prototype의 프로퍼티이다.
  스코프와 마찬가지로 양방향으로 가리킬 경우 무한루프에 빠지므로 접근자 프로퍼티를 통해 접근하고 교체할 수 있도록 구현되어 있다.
  코드 내에서 직접 사용하는 것은 권장되지 않는다. 직접 상속을 통해 상속한 객체는 **proto\*\*를 상속받지 못하기 때문이다. 따라서 Object.getPrototypeOf()와 Object.setPrototypeOf()의 사용을 권장한다.

```jsx
const test = {};
Object.getPrototypeOf(test); // test.__proto__;
Object.setPrototypeOf(test, { a: 1 }); // test.__proto__ = {a : 1};
```

- **함수 객체의 prototype 프로퍼티**
  함수 객체만이 소유하는 prototype 프로퍼티는 생성자 함수가 생성할 인스턴스의 프로토타입을 가리킨다. 따라서 화살표 함수와 축약 메서드는 prototype 프로퍼티를 소유하지 않고 프로토타입을 생성하지도 않는다.
  객체의 **proto** 접근자 프로퍼티와 함수 객체가 가지고 있는 prototype은 결국 동일한 프로토타입을 가리킨다.
- **프로토타입의 constructor 프로퍼티와 생성자 함수**
  모든 프로토타입은 constructor 프로퍼티를 갖는다. 이 프로퍼티는 자신을 prototype로 참조하고 있는 생성자 함수를 가리킨다. 이 연결은 함수가 생성될 때, 즉 함수 객체가 생성될 때 이뤄진다.

### 리터럴 표기법에 의해 생성된 객체의 생성자 함수와 프로토타입

> 리터럴 표기법과 같이 new 연산자 없이 인스턴스를 생성하는 객체 생성 방식도 있다.

리터럴 표기법으로 생성된 객체의 경우 constructor 프로퍼티가 가리키는 생성자 함수가 반드시 객체를 생성한 생성자 함수라고 단정할 수 없다.

객체 리터럴로 생성된 객체는 생성자 함수에 의해 생성된 객체는 아니지만, 큰 틀에서 보면 생성자 함수로 생성된 객체와의 큰 차이가 없다. 따라서 프로토타입의 constructor와 연결된 생성자 함수를 리터럴 표기법으로 생성한 객체의 생성자 함수로 생각해도 된다.

### 프로토타입의 생성 시점

> 프로토타입은 함수가 생성되는 시점에 더불어 생성된다. 생성자 함수와 프로토타입은 쌍으로 존재

- 사용자 정의 생성자 함수의 프로토타입
  constructor 함수가 평가되어 생성될 때 프로토타입도 함께 생긴다.
  생성된 프로토타입은 constructor 프로퍼티만 가지고, 자신도 객체이므로 Object의 프로토타입을 상속받는다.
- 빌트인 생성자 함수의 프로토타입
  빌트인 생성자 함수는 전역 객체가 생성되는 시점에 생성되고, 이 때 프로토타입도 같이 생성된다.

### 객체 생성 방식과 프로토타입의 결정

> 객체를 생성하는 다양한 방식은 OrdinaryObjectCreate 추상 연산을 통해 생성된다.

- 객체 리터럴로 생성한 객체
  객체 리터럴이 평가되면 추상 연산에 의해 Object 생성자 함수와 그 프로토타입과 연결된다.
- Object 생성자 함수로 생성한 객체
  인수 없이 호출하여 생성할 경우 빈 객체를 반환하고, 그 객체는 Object 생성자 함수와 프로토타입과 연결된다. 리터럴 방식과의 차이는 프로퍼티를 추가하는 방식이 다르다.
- 사용자 정의 생성자 함수로 생성한 객체
  동일하게 추상 연산 OrdinaryObjectCreate을 호출하고, 생성자 함수의 prototype에 연결된 객체를 프로토타입으로 전달한다. 해당 프로토타입에 프로퍼티를 추가하여 모든 인스턴스가 공유 할 수 있는 상속을 구현할 수 있다.

### 프로토타입 체인

> 자바스크립트는 객체의 프로퍼티에 접근하려고 할 때 해당 객체에 접근하려는 프로퍼티가 없다면 [[prototype]] 내부 슬롯의 참조를 따라 자신의 부모 역할을 하는 프로토타입의 프로퍼티를 순차적으로 검색한다. 이를 프로토타입 체인이라고 한다. 상속을 구현하는 메커니즘이다.

스코프 체인과 프로토타입 체인은 서로 협력하여 식별자와 프로퍼티를 찾는데 사용된다.

### 오버라이딩과 프로퍼티 섀도잉

> 프로토타입과 같은 이름의 프로퍼티를 추가할 경우 프로토타입의 값이 바뀌는 것이 아닌 인스턴스의 프로퍼티로 추가된다. 이를 통해 오버라이딩을 할 수 있고, 부모 프로퍼티는 섀도잉이 발생한다.

인스턴스 객체를 통해 프로토타입의 프로퍼티를 변경 또는 삭제할 수 없다.

### 프로토타입의 교체

> 프로토타입은 임의의 다른 객체로 변경할 수 있다. 동적으로 변경 가능

- 생성자 함수에 의한 프로토타입의 교체
  생성자 함수의 prototype 프로퍼티에 직접 객체를 넣어준 경우 constructor 프로퍼티가 존재하지 않으므로 교체된 객체의 부모인 Object의 constructor가 호출되어 Object가 나온다.
  교체할 객체 내에 constructor 프로퍼티를 직접 추가하여 연결을 살려낼 수 있다.
- 인스턴스에 의한 프로토타입의 교체
  인스턴스의 **proto**를 사용하여 프로토타입을 교체하는 경우 이미 생성된 인스턴스의 프로토타입을 교체하는 것이다. Object.setProtoTypeOf(객체, 부모객체)로 프로토타입을 교체할 수 있다.

프로토타입의 교체를 통해 객체의 상속 관계를 동적으로 변경하는 것은 번거로우므로 직접 교체하지 않는 것이 좋다. 직접 상속을 사용하는 것이 좋다.

### instanceof 연산자

> 이항 연산자로서 좌변에 객체 식별자, 우변에 생성자 함수 식별자를 피연산자로 받는다.

프로토타입 체인에 존재는지를 확인하고 boolean을 반환하므로 cunstructor의 연결과 상관없이

동작한다. 인스턴스에서 직접 프로토타입을 바꾸지 않는 한 체인은 끊어지지 않는다.

### 직접 상속

> Object.create(프로토타입 객체[, {프로퍼티 키 : 디스크립터 객체}]);

위 메서드를 사용할 경우 new 연산자 없이 객체 생성이 가능하고, 프로토타입을 직접 지정하면서 객체를 만들 수 있다. 첫번째 인자에 null을 넣어 생성하면 Object.prototype을 상속받지 않는, 프토로타입에 종점에 있는 객체가 생성되므로 Object가 가지고 있는 메서드는 직접 호출하는 것 보다 간접 호출로 사용하는 것이 권장된다.

ES6에선 객체 내부에서 **proto**를 이용하여 직접 상속을 구현할 수 있다.

### 정적 프로퍼티 / 메서드

> 생성자 함수로 인스턴스를 생성하지 않아도 참조/호출 할 수 있는 프로퍼티를 말한다.

생성자 함수 또한 객체이므로 자기 자신의 프로퍼티를 가질 수 있다.

### 프로퍼티 존재 확인

1. in 연산자

   key in object 를 이용해 존재 여부를 확인할 수 있다.

   확인 대상뿐만 아니라 모든 프로토타입의 프로퍼티를 확인하므로 주의가 필요하다.

   ES6에서 도입된 Reflect.has(객체,키)를 이용해도 동일하게 동작한다.

2. Object.prototype.hasOwnProperty

   프로토타입 체인을 확인하지 않고 호출한 객체 고유의 프로퍼티인지 확인한다.

### 프로퍼티 열거

- for( let key in 객체) 문
  상속받은 프로퍼티까지 모두 열거한다.
  프로퍼티의 enumerable이 false일 경우 열거할 수 없다.
  for…in문은 열거할 때 순서를 보장하지 않는다. 모던 브라우저는 자체적으로 정렬해준다.
  배열은 in문 사용시 프로퍼티가 출력될 수 있으므로 for of 나 forEach 등을 사용하는 것이 좋다.
- Object.keys/values/entries 메서드
  for…in 문은 상속받은 프로퍼티까지 열거하므로 자신의 프로퍼티인지 확인하는 과정이 추가로 필요하기 때문에 객체 자신의 프로퍼티만 열거하기 위해서는 Object.keys/values/entries를 사용하는 것이 좋다.

# 💥 페어 프로그래밍

### 스탑워치

setTimeout 또는 setInterval을 사용시 딜레이 시간이 4ms보다 작을경우 알아서 4ms로 동작시키는 문제가 있는 것을 책에 써있었지만 직접 만들어보며 다시 알 수 있었다. ms를 10 단위로 증가시키며 이벤트를 발생시켜 해결했고, 버튼 2개를 가지고 4개의 동작을 하는 부분도 구현하며 이벤트 핸들러를 조작하였다.

### Tabs

비동기로 정보를 받아와 비동기처리가 완료되기 전까지 로딩 이미지를 띄워주고 프로미스 상태가 fullfilled가 되었을 때 화면을 그려내는 방법을 배울 수 있었다. 또힌 탭 선택에 대한 하이라이트 처리를 클래스가 아닌 dimmed 같이 요소를 두어 위치를 바꾸어주는 방식을 활용하였다.

### Toaster

평소의 innerHTML 방법과 다르게 이미 그려진 toast를 다시 그리면 트렌지션 이벤트가 발생하기 때문에 새로운 요소를 만들어서 추가하는 방법을 사용해야했다. createElement를 사용하여 toast를 선택된 버튼에 따라 해당 내용으로 만들어내어 바디 안에 추가해주는 방법을 사용하였다. 그리고 요소를 시간초 후에 제거하기 위하여 setTimeout을 사용했고 이 부분에서 리펙토링이 필요할 것 같다!

### Autocomplete

tabindex를 활용해서 포커싱이 갈 수 없는 요소에 포커스를 줄 수 있게 되고, focus 함수를 사용하여 요소에 포커스를 줄 수 있었다. 또 기본 이벤트인 방향키 스크롤 이벤트를 keyup으론 막을 수 없었지만 keydown으로 해결할 수 있었다. 또 정규표현식을 활용해서 replace로 텍스트의 부분만 strong 태그로 감싸는 방법을 사용해 검색된 문장을 표시할 수 있었다.

# 🤯 하루을 마치며…

갈수록 어려운 문제가 등장하며 점점 고민해야할 부분들이 늘어났다. 물론 최대한 간단하고 이해하기 쉽게 코딩을 진행하긴 했지만 기능별로 분류하거나 고쳐야할 부분들이 많이 존재하는 것 같다. 코딩을 같이 진행하다보니 속도적인 부분이나 서로 다른 생각을 조율해 나가는 과정에서 내가 보지못한 부분에 대한 아이디어를 얻고 또 내 의견을 설득해나가며 협업에 대한 배움을 얻을 수 있어 좋은 것 같고, 이번주와 다음주를 기반으로 바뀐 조원과의 페어 프로그래밍도 지금처럼 차근차근 조율해나가며 잘 진행해야겠다!
