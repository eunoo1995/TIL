# 📖 오늘의 학습

## SOP(same origin policy)

- 다른 출처의 리소스를 제한하는 보안 방식
- 동일한 프로토콜, 호스트(도메인), 포트의 요청만 허용
- 필요한 외부 리소스의 사용까지도 제한 됨

## CORS(cross origin resource sharing)

- 출처가 다른 리소스 요청에 대해 서버에 동의를 구하는 정책
- 브라우저가 외부 출처의 cors를 판단, 파기 (서버의 로그엔 정상 기록)

## 해결 방법

### 서버

- 응답 헤더에 `Access-Control-Allow-Origin` 추가하기
  - 보안을 위해 가급적 \* 보단 구체적 출처 명시 필요
  - 클라이언트 요청에 `Credentials: include` 가 포함된 경우 \*를 사용하면 에러
    (`Access-Control-Allow-Credentials: true` 인증 정보에 대한 속성을 포함시켜야 에러 발생x)

### 클라이언트

- Proxy를 활용해 우회하여 전송
  - 개발 단계에서만 적용, 빌드 후 프로덕션 환경에서는 프록시 처리가 되지 않는다.

# 💥 수업 정리

- 정적 타입 언어들은 타입에 대한 오류가 발생할 수 없다.
- 재할당은 에러의 발생 확률을 상당히 높힌다.
- 에러를 전파시켜 상위에서 잡아내는 것이 좋다.
- await는 try catch 를 필수로 사용할 것
- 콜러는 결국 자신을 호출한 컨텍스트
- 비동기 콜백의 콜러는 브라우저, 즉 스택 상 콜러가 없어 에러 캐치 불가
- 에러 처리는 회사마다 다 다른 방법을 가지고 있어 학습할 때 애매하다.
- 예외 상황이 발생하면 에러를 발생시키는 것이 좋다
- throw new error(’에러 메세지’);
- 에러를 상세하게 만들어내고 싶을 경우 Error를 상속받아 만들 것
- finally 구분에서 보통 setTimeout 을 지우고 마무리 하는 등의 로직
- 어플리케이션을 만들기 위해서는 모듈을 가지고 있어야 한다.
- 모듈을 쪼개는 단위는 기준이 없다. 보통 기능 단위
- 폴더, 파일 이름도 식별자 의미있게 지을 것
- 기능별, 화면별 등 구조를 잡는 기준들이 있다.
- 회사에서 결정한 컨벤션을 따른다.
- 전역을 공유하고 있기 때문에 재할당의 문제가 발생한다.
- 모듈에서 가장 심플한 상황은 서로 몰라도 될 때!
- 모듈은 모듈(파일) 스코프를 가진다.
- export 를 사용하여 다른 모듈에서 볼 수 있게 해준다.
- export를 한 애를 사용하려면 import로 받아와야 한다.
- 모듈로 하면 클래스를 사용해 정보은닉을 하지 않아도 된다.
- 클로저도 내보내진 애가 모듈 내부를 참조할 경우 생성
- es6+는 정식 사양 esNext는 제안 사안들까지 포함
- babel은 기존에 문법이 있는 것만 트렌스파일링 할 수 있다.
- promise 같이 기존 문법으로 만들 수 없는 것을 해결하기 위해 폴리필을 사용해야 함
- 바벨은 준 표준이라 모든 회사가 대부분 사용한다.
- js는 webpack으로 번들링을 한다.
- webpack은 1년에 1번정도 버전 업을 하면서 이전 버전에 사용하던 것이 안먹힐 수 있다.
- webpack같은 tool들은 빠르게 찾아 적용시키는 것이 중요하지 다 공부하는 것이 목표가 아니다.
- 개발자의 소양은 빠른 학습 능력?
- **학습하고자 하는 툴이나 기술의 공식 문서를 읽어야 한다.**
- 컨셉이나 get started 정도는 알아야 한다.
- 블로그들의 정보는 부정확할 가능성이 허다하다.
- 툴을 잘 다루는 것도 개발 실력이다. cli도 잘 다룰 줄 알아야한다.
- 웹서버와 어플리케이션 서버가 분리되어 있을 경우 요청을 보내는 서버가 다를 수 있다.
- 서버에서 cors를 허용해주어야 브라우저가 에러를 발생시키지 않는다.

![이름 없는 노트북 (1)-87.jpg](https://s3.us-west-2.amazonaws.com/secure.notion-static.com/267bdc3b-b5aa-47d0-b01a-c5405f337a34/%EC%9D%B4%EB%A6%84_%EC%97%86%EB%8A%94_%EB%85%B8%ED%8A%B8%EB%B6%81_%281%29-87.jpg?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&X-Amz-Credential=AKIAT73L2G45EIPT3X45%2F20220902%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20220902T055059Z&X-Amz-Expires=86400&X-Amz-Signature=416002134b2e215deb720998026b643ec481cd53fb9d15f5048a8be3b028f2af&X-Amz-SignedHeaders=host&response-content-disposition=filename%20%3D%22%25EC%259D%25B4%25EB%25A6%2584%2520%25EC%2597%2586%25EB%258A%2594%2520%25EB%2585%25B8%25ED%258A%25B8%25EB%25B6%2581%2520%281%29-87.jpg%22&x-id=GetObject)

- 패턴이 중요한 것이 아니라 나의 프로젝트가 어떤 흐름으로 진행할 것인지가 중요
- model → state라고 한다. 이것으로 렌더링
- 아키텍쳐도 결국 컨벤션처럼 규칙을 정한 것이다. 통일성을 위해
- 완전한 분리는 있을 수 없다. 가리키고 있는 애는 알아야 한다.
- 양방향일 경우 복잡도가 높아진다.
- 화살표는 사실 함수 호출의 의미, 뷰에서 이벤트 핸들러 호출 → 컨트롤러가 내부에서 비지니스 로직 호출 → 비지니스 로직이 실행되면서 데이터 처리 후 렌더를 호출
- 함수를 API라 부를 수 있는 이유가 상호간을 연결해주는 인터페이스의 역할을 하기 때문에
- 생산성과 시너지가 발생하는 것이 협업이다.
- 아키텍쳐도 하나의 협업의 방식이다.
- 이미 구현되어진 아키텍쳐 → 프레임워크 사용, 흐름을 이해하고 사용해야 한다.
- state는 뷰에 영향을 주는 데이터, 뷰에 영향을 주지 않는 데이터는 state가 아니다.
- 리엑트는 리렌더링의 자동화를 지원한다. state의 변경만 하면 알아서 뷰에 영향을 준다.
- 돌아가는게 중요한게 아니고 큰 그림을 이해하고 어떻게 하면 더 좋은 코드일지 항상 고민할 것

# 🤯 하루를 마치며…

오늘은 책을 마무리했다. 어떻게 보면 많이 벅찬 스케줄로 쉬지않고 달려와서 이해가 부족해도 넘어간 부분이 있다고 생각한다. 그래도 혼자 읽었을 때와 달리 강사님이 해주시는 중요한 얘기들과 동기들과 러버덕으로 대화를 나누면서 많은 것을 얻을 수 있었던 시간인 것 같다! 수업을 듣기 전엔 재대로 된 이해 없이 돌아가는 코드를 작성했다면 이제부터 만들 때는 한 줄 한 줄이 어떤 의도에서 이런 코드로 작성했는지에 대한 의미를 가지고 좋은 코드를 작성해 나가기위해 노력해야겠다!
