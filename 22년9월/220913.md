# 📖 딥다이브 러버덕 복습

## 프로퍼티 어트리뷰트

### 내부 슬롯과 내부 메서드

> 자바스크립트 엔진에서 실제로 동작하는 프로퍼티이지만 직접 접근하거나 호출할 수 있는 방법을 제공하지 않는다. 일부에 한해 간접적으로 접글할 수 있는 수단을 제공한다.

### 프로퍼티 어트리뷰트와 프로퍼티 디스크립터 객체

> 엔진은 프로퍼티를 생성할 때 상태를 나타내는 프로퍼티 어트리뷰트를 기본값으로 자동 정의한다.

```jsx
Object.getOwnPropertyDescriptor(객체, "프로퍼티 키");

// 프로퍼티 디스크립터 객체를 반환한다.

Object.getOwnPropertyDescriptors(객체);

// 프로퍼티 디스크립터 객체들을 반환한다.
```

### 데이터 프로퍼티와 접근자 프로퍼티

- **데이터 프로퍼티**
  키와 값으로 구성된 일반적인 프로퍼티이다.
- **접근자 프로퍼티**
  자체적으로 값을 갖지 않고, 호출되는 접근자 함수로 구성된 프로퍼티다.

### 프로퍼티 정의

> Object.defineProperty 메서드를 이용해 프로퍼티의 어트리뷰트를 정의할 수 있다.

### 객체 변경 방지

> Object.defineProperty 또는 Object.defineProperties를 사용해 재정의 할 수 있고, 자바스크립트는 자체적으로 객체의 변경을 방지하는 다양한 메서드를 제공한다.

- 객체 확장 금지 Object.preventExtensions() : 프로퍼티 추가 금지
- 객체 밀봉 Object.seal() : 프로퍼티 추가, 삭제, 재정의 금지 읽기 쓰기 가능
- 객체 동결 Object.freeze() : 프로퍼티 읽기만 가능

> 불변 객체를 만들기 위해서는 재귀를 이용해 중첩 객체들 까지도 동결시켜야 한다.

## 생성자 함수에 의한 객체 생성

### Object 생성자 함수

> new 연산자와 함께 Object 생성자 함수를 호출하면 빈 객체를 반환한다.

### 생성자 함수

- **객체 리터럴에 의한 객체 생성 방식의 문제점**
  동일한 프로퍼티를 갖는 여러개의 객체를 생성해야 하는 경우 비효율적이다.
- **생성자 함수에 의한 객체 생성 방식의 장점**
  탬플릿처럼 new 키워드와 함께 호출하여 구조가 동일한 객체 여러개를 만들 수 있다.
  new 키워드를 생략하고 호출하면 일반 함수처럼 작동한다.
- **생성자 함수의 인스턴스 생성 과정**
  인스턴스를 생성하고 생성된 인스턴스르 초기화한다.
  new 키워드와 함께 호출하면 암묵적으로 빈 객체를 생성하고 this에 바인딩한다.
  → 코드가 한 줄씩 실행되어 인스턴스를 초기화한다. 프로퍼티나 메서드 추가
  → 모든 내부 코드가 실행 된 후 암묵적으로 this에 바인딩된 객체를 반환한다.
  임의의 객체를 반환하면 this가 반환되지 못한다. 원시 값 반환은 무시 return 생략
- **내부 메서드 [[Call]]과 [[Construct]]**
  함수는 일반 객체와 동일하게 동작하며, 함수 객체만의 내부 슬롯과 메서드도 가진다.
  함수 객체는 호출을 할 수 있어야 하므로 반드시 callable이여야 한다.
  하지만 모든 함수가 constructor는 아니다.
- **constructor 와 non-constructor의 구분**
  - constructor : 함수 선언문, 표현식, 클래스
  - non-constructor : 축약 메서드, 화살표 함수
- **new 연산자**
  constructor인 함수를 new와 함께 호출하여 생성자 함수로 동작하게 한다.
  파스칼 케이스로 작성하여 일반 함수와 구별할 수 있도록 노력한다.
- **new.target**
  생성자 함수가 new 연산자 없이 호출되는 것을 방지하기 위해 지원
  constructor 함수 내부에서 암묵적인 지역 변수와 같이 사용하며 메타 프로퍼티라 부름
  함수 내부의 new.target은 함수 자신을 가리킨다. new 없이 호출하면 undefined
  IE에선 지원하지 않음, 스코프 세이프 생성자 패턴을 통해 검사
  → this가 전역인지 프로토타입 체인에 연결되어 있는지 확인 (this instanceof 생성자함수)
  빌트인 생성자 중 String, Number, Boolean은 new 없이 호출하면 원시 값 반환

## 함수와 일급 객체

### 일급 객체

1. 무명의 리터럴로 생성 가능, 즉 런타임에 생성 가능
2. 변수나 자료구조에 저장할 수 있다.
3. 함수의 매개변수에 전달 가능
4. 함수의 반환값으로 사용할 수 있다.

### 함수 객체의 프로퍼티

- **arguments 프로퍼티**
  전달된 인수들의 정보를 담고 있는 순회 가능한 유사 배열 객체
  함수 내부에서 지역 변수처럼 사용된다.
  매개변수의 개수를 확정할 수 없는 가변 인자 함수를 구현할 때 유용하다.
  ES6 Rest 파라미터의 도입으로 번거로움 해결, 지원하지 않는 경우 arguments 사용
- **caller 프로퍼티**
  비표준 프로퍼티, 함수 자신을 호출한 함수를 가리킨다.(고차 함수?)
- **length 프로퍼티**
  매개변수의 개수를 가리킨다.
- **name 프로퍼티**
  함수의 이름을 나타낸다. 익명함수 ES5 : “”, ES6 : 변수(식별자) 이름
- ****proto** 접근자 프로퍼티**
  모든 객체는 프로토타입 객체를 가리키는 [[prototype]] 내부 슬롯을 갖는다.
  객체 자신의 프로퍼티가 아닌 prototype이 제공하는 접근자 프로퍼티이다.
  간접적으로 프로토타입 객체에 접근할 수 있게 해준다.
- **prototype 프로퍼티**
  생성자 함수로 호출할 수 있는 객체, 즉 constructor만이 소유하는 프로퍼티이다.
  생성자 함수가 생성할 인스턴스의 프로토타입 객체를 가리킨다.

# 💥 페어 프로그래밍

- 개발 방법론인 에자일 방식에서 사용하는 방법
- 코드의 책임을 나누어가질 수 있다. 이타적 프로그래밍
- 즉각적인 피드백으로 품질 향상
- 나중에 커질 문제가 미리 드러난다.
- 단점은 느린 것
- 구현에 급급하여 책 내용을 녹여내지 못한다.

### 역할

- 네비게이터 - 큰 그림을 보고 바로잡아주는 역할
- 드라이버 - 직접 구현하며 만들어가는 역할

### 순서

- 요구사항에 대한 동작하는 코드 일단 빨리 만들고
- 만드는 과정의 3배 리펙토링에 사용
- 좋은 코드 나쁜 코드에 대한 선구안을 가지는 연습을 해야한다.
- 중복 제거, 이쁜 이름, 함수 한가지 기능 → 1순위

### 방법

- 하루를 마무리 할 때 회고 필수
- 정해진 시간마다 역할을 바꾸어가며 진행하기

# 🤯 하루을 마치며…

1. scrolling goto top

   자바스크립트 라이브러리인 lodash의 srottle을 사용하여 스크롤 이벤트의 반복 주기를 지정하여 이벤트의 과다한 발생을 방지했다. 또한 window.scroll() 메서드를 사용하여 원하는 좌표로 이동할 수 있고, 부드럽게 화면 전환이 발생하는 속성을 줄 수 있었다.

2. counter

   클로저를 활용한 간단한 예제지만 클로저를 직접 사용하여 정보은닉을 구현하고 값을 클로저를 통해 안전하게 변경하고 외부에서 접근할 수 없게 구현하는 것이 의미있었다.

3. is palindrome

   정규표현식을 사용하여 입력받은 문장의 특수문자를 제거하였고, form 태그 내부의 태그들이 순서대로 프로퍼티로 들어와 e.target[0]으로 인풋 값에 접근할 수 있었던게 새로 안 사실이다. 매개변수에 재할당 하는 것도 하면 안된다.

4. Dark mode

   인라인 스타일로 준게 아닌 경우 dom에는 해당 스타일 값을 알 수 없으므로 속성 값을 가지고 올 수 없는 문제가 있었다. 그래서 css값을 사용하려면 getComputedStyle()을 사용하여 전체를 다시 읽어들여 해당 요소의 스타일 속성 값을 가지고 올 수 있다는 것을 배웠다. 아쉬운 점은 트렌지션 이벤트가 초기 렌더링 시 발생하는 것을 방지하는 것에 있어 아직 완벽한 코드가 아닌 것 같아 리펙토링을 고민해보아야할 것 같다. toggle()의 두번째 인수로 조건식을 주어 활용하는 것도 익숙해져야할 것 같다. css 변수는 가급적 읽기전용으로 사용하는 것이 좋고 어쩔 수 없을 때는 변경될 수 있다. transition end 이벤트를 캐치할 수 있다.

5. 5.PopupModal

   이벤트를 명확하게 걸어주지 않았는데 원하던대로 작동하여 만족하고 있었지만 유지보수의 관점에서 명확하지 않은 코드는 좋지못하다는 피드백을 받았다. 또 이벤트 위임을 걸어 탈출 요소를 걸어주는 것이 까다로웠는데 어떻게 수정하면 좋을지를 좀 더 고민해보아야할 것 같다.
