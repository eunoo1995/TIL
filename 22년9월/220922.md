# 📖 페어 프로그래밍

## 1**. Scrolling goto top**

첫 구현 당시 요구사항에 따라 수직 스크롤 거리에 따라 버튼을 활성화하고, 스로틀 메서드를 활용하여 스크롤 이벤트의 발생 주기를 제한했다. lodash 라이브러리를 cdn으로 사용했을 때 따로 require 하지 않고 바로 사용할 수 있다는 것을 알았고, \_ 로 사용할 수 있는 이유가 low dash가 라이브러리의 컨셉이기 때문이란 것을 알았다! 첫 구현의 스크롤 이벤트 주기가 너무 커 시간을 줄여주었고, 아이콘의 display를 제어하는 최소 거리 값을 상수로 바꿔주어 가독성을 높였다. 또한 **Window.pageYOffset 속성은** Deprecated 되었다는 것을 확인하여 scrollY 속성을 사용하였습니다. 또 window.scroll() 메서드를 사용하여 원하는 좌표로 이동할 수 있는 것을 알았고, 프로퍼티 behavior: 'smooth' 를 주어 부드럽게 이동할 수 있다는 것도 처음 알았다! window.scroll()와 window.scrollTo() 메서드는 차이가 없어 왜 같은 동작을 하는 함수가 두개인지에 대해서는 찾을 수 없었다.

## 2. Counter

구현 당시 이벤트 위임이 좋다고 생각하여 위임을 사용하여 이벤트를 등록하였고, 클로저를 사용하여 값을 안전하게 사용하는 것에만 초점을 두었다. 모듈이 아닌 js에서는 전역을 공유하고 있으므로 구지 전역에서 알 필요 없는 데이터들 까지도 즉시실행 함수 내부로 이동시켜 가독성을 높였다. 결론적으로 모듈은 각자의 스코프를 가지고 내보내기 하지 않은 데이터는 모두 은닉되므로 모듈을 사용하는 것이 좋다는 것을 느낄 수 있었다. 또한 정적으로 존재하는 요소인데 구지 위임을 사용하여 한번에 관리할 필요 없이 따로 걸어주는 것이 더 좋을 때도 있다는 것을 알았다.

## 3**. Is palindrome?**

정규표현식을 사용하여 입력받은 문장의 특수문자를 제거하고, **palindrome** 여부를 판단하는 함수를 외부에서 선언하여 가독성을 높이고 enter와 click을 한번에 잡아내기 위해 submit 이벤트로 위임하여 이벤트를 관리했다. 정규표현식을 체크하는 과정에서 매개변수에 재할당을 하는 실수를 했고 이 부분을 수정하였다. 전역 공간에 함수와 변수를 사용하여 2번과 마찬가지로 리팩토링 과정에서 즉시실행 함수로 감싸주어 불필요한 정보가 전역 공간에 존재하는 것을 방지하고 이벤트 핸들러를 반환하여 가독성을 높여주었다. 또 submit 이벤트 객체가 form 내부의 제출 요소들을 배열로 가지고 있어 그걸 활용하여 접근했고, 좋은 아이디어라고 생각했지만, 얘도 마찬가지로 타겟을 가지고 처리하기보단, 요소를 selector로 가지고와서 사용하는 것이 더 좋다는 판단하에 수정하였다.

## 4**. Dark mode**

window.matchMedia('(prefers-color-scheme:dark)').matches 를 사용하여 os의 현재 테마 모드를 가져올 수 있다는 것을 처음 알았다! 로컬 스토리지를 활용하여 페이지의 기본 테마를 설정하고, 존재할 경우 os에서 사용중인 모드보다 스토리지에 저장된 모드를 더 우선으로 렌더링하고, 초기에 다크모드로 렌더링할 시 발생하는 트렌지션 효과가 끝난 후 화면을 띄워주기 위해 처음에는 duration 속성 자체를 처음에 0으로 설정했다가 다시 원래의 값으로 돌려놓는 방법을 선택했는데 부자연스러운 방법이란 생각이 들었고 강사님이 css 변수를 직접 제어하는 것은 되도록 지양하라는 피드백을 주셔서 방법을 고민하던 중 타이머 함수를 활용하였다. 리팩토링을 진행하며 마찬가지로 불필요한 데이터가 전역에 존재하는 것을 방지하기 위해 즉시실행 함수로 감싸 캡슐화를 진행하였고, 스토리지에 저장된 테마를 가져오고 세팅하는 로직을 함수로 분리하여 가독성을 높였다. 또 함수 내부의 if문을 null 병합 연산자로 변경하여 내부 로직의 가독성을 높였다.

## 5**. Popup modal**

폼 태그 안에 3개의 버튼이 병렬적으로 존재하여 ok버튼만 submit을 발생시키기 위해 다른 버튼에는 type 어트리뷰트를 button으로 지정해주었다. 첫 마크업 때 시멘틱에 대한 고민을 하던 중 강사님의 피드백을 듣고 결국 접근성의 방향도 개발자의 스타일이나 회사의 컨벤션을 따르겠다는 생각이 들었다. 또 구현 단계에서 dimmed 팝업을 구현할 때 z-index를 활용하여 전체 화면을 감싼 요소를 주었다가 wrapper div를 추가하여 전체 요소가 아닌 해당 요소의 사이즈를 전체로 바꾸어주고 bg에 투명도를 주었다. 또 modal의 click 이벤트에서 걸러내는 조건식을 wrapper를 사용하게 되면서 간소화할 수 있었고, click 이벤트로 처리했을 때 마치 submit 처럼 동작하는 것을 명시적으로 submit으로 바꾸어주어 합당하게 동작하도록 하였다.

## 6**. Stopwatch**

여기부턴 점점 로직이 복잡해져 구현 단계의 코드가 가독성이 좋지 않은 것 같다. 시간이 흘러가는지의 여부에 따라 버튼이 컨트롤 되고 지금까지 흘러간 시간을 기억해야 하며, lap이 몇개가 존재하는지를 기억해야 할 것 같아 세가지를 상태로 관리하였다. date 객체와 interval을 사용하여 10ms 간격으로 계산하여 렌더하는 함수를 호출하여 임워치를 구현하였다. 어려웠던 점은 버튼 한개가 두 종류의 버튼으로 동작하기 때문에 어쩔 수 없이 조건문을 걸어야하는 부분이었다. 중복된 로직이 존재하여도 서로 반대 기능을 하기 때문에 결국 함수로 빼냈지만 함수 내부에서도 삼항 연산자로 처리해주어야 하는 것이 마음에 들지 않았지만 뾰족한 해결 방법이 떠오르지 않았다…완전 만족스럽지는 않지만 세명의 의견을 최대한 수렴하여 리팩토링을 진행하였다.

## 7**. Tabs**

처음 데이터를 받아오는 비동기 함수를 사용할 때 프로미스 then 메서드를 사용하여 받아오면서 catch로 에러처리도 해주지 않았다. 동료들의 피드백을 통해 async await 를 이용하여 가독성을 높였고 try catch문을 사용하여 에러에 대한 처리까지도 완료할 수 있었다. 또 선택되어진 탭을 구별해주는 계산을 css에서 하고 있으므로 transform에 현재 포커싱 된 요소의 탭 인덱스를 탭 사이즈에 곱하여 그만큼 밀어주어 선택되어진 요소를 표시할 수 있도록 하였다. 비동기 함수를 외부에서 즉시실행 함수 내부로 옮겨주었고, 직접적으로 초기값을 주는 것 보다 탭 인덱스를 클로저의 변수로 두어 관리하여 안티 패턴을 제거하여 가독성을 높였다.

## 8**. Toaster**

처음 커밋을 하고 사소한 변화가 생겨 그것까지 포함시키기 위해 커밋을 취소하는 과정에서 Revert를 사용하여 커밋을 취소하고 그 실수 또한 기록으로 남길 수 있었다. 처음에는 구현에 초점을 맞추어 토스트 요소를 추가하는 과정에서 발생하는 공통된 로직들을 분리해내지 못했고, 이벤트 위임을 사용하여 하나의 이벤트에서 타입을 여러가지로 만들어내는 방법을 선택하여 createToast 함수의 로직이 복잡해졌다. 이를 해결하기 위해 함수가 하나의 일을 하도록 분리하고, 토스트의 높이 계산 로직도 함수로 분리해냈다. 삭제하는 과정에서 removecheild를 사용했을 때 배열의 0번째 요소를 삭제하는 로직으로 만들어 없는 요소에 삭제메서드를 사용하는 에러가 발생해서 이를 해결하기 위해 remove 메서드로 변경하였다.

## 9**. Autocomplete**

구현 당시에는 초기 목록과 검색된 추천 목록을 만들어 그려내는 것까지를 하나의 함수로 만들었는데 함수가 하나의 일을 할 수 있도록 이 로직을 분리시켰다. 또한 해당 요소 외부를 클릭했을 때를 잡아내기 위해서 match 말고 closest를 활용하여 내부 모든 요소까지 포함시킬 수 있다는 것을 알았고 키보드 keydown 이벤트의 위, 아래 방향키에 기본적으로 스크롤을 움직이는 동작이 걸려있어 이를 해결하기 위해 기본 동작을 제거하고 이전, 다음 요소에 포커스를 이동시키도록 구현하였다. tabIndex 어트리뷰트를 사용하여 포커스가 존재하지 않는 요소에도 포커스를 발생시킬 수 있다는 것을 알았고, 이벤트의 기본 동작이 있는지를 체크해야 할 것 같다고 생각했다. replace 함수에서 두번째 인수인 교체할 문자열 내부에 $&사용하면 첫번째 인수로 준 검색할 조건에 매치된 문자열이 넘어온다. 그래서 콜백 함수로 처리할 필요가 없어졌다. 또 배열의 디스크럭처링을 활용하여 가독성을 높여주었다

## 🔥 페어 프로그래밍을 하면서 느낀 점

구현

드라이버: 옆에서 본다고 생각하니 머리가 잘 안돌아가는 느낌이였는데 하다보니 적응이 되는 듯… 생각을 말로 표현하니까 정리가 돼서 좋은 듯… 옆에서 생각치 못한 것을 얘기해줘서 시너지효과가…

네비게이터: 머리가 잘 돌아간다… 비판하는 맛이 있다… 다정하게 말하는 연습을 해야한다고 한다…-김은우 왈- 2명이라 의견이 두배가… 다양하고 좋았다…

오늘은 에너지 소비가 컸다. 문제가 복잡스러워서 그런 것 같다.

그래도 빠르게 문제를 해결했다…생각보다 빠르게

semantic 마크업 중요하지만…div를 안 좋게 보지말자…

냄새나는 것을 잘 해결하자…

리팩토링

9월 16일에 페어프로그래밍 과제를 완료하고 남은 일주일은 좋은 코드가 되도록 수정하기로 계획했습니다. 지난 주 코드를 구현할 때는 행복했지만 어제 첫 리팩토링을 하면서 아쉬운 점이 많았습니다.

코드 리팩토링에 대한 경험이 부족해서 큰 구조를 생각하지 못 하고 중복되는 코드 기준으로 함수를 만들고, 변수명과 함수명 수정하는 것이 다였습니다. 그러나 강사님의 코드를 보고 가독성이 좋은 코드를 짜기 위해서 단순히 코드가 아니라

**프로그램이 동작하는 흐름**

을 기준으로 함수를 만들어야한다는 것을 깨달았습니다. 또한, 함수가 여러가지 일을 하는 것이 아니라

**핵심이 되는 한 가지 동작**

을 하여 잠깐 봤음에도 전체 코드가 쉽게 읽혔습니다.

코드 구현 시 vs code 라이브 서버를 이용하여 한명은 드라이버, 나머지는 네비게이터 역할을 하여 효과적으로 프로젝트를 진행하였습니다. 그러나 리팩토링을 하면서 좋은 코드에 대한 기준이 각자 달랐기 때문에 진행 속도가 더뎌지는 문제가 있었습니다.

어제의 아쉬운점들을 보완하기 위해 오늘은 새로운 방식으로 페어 프로그래밍을 진행했습니다. 먼저, 각자 생각하고 실험할 수 있는 충분한 시간을 가졌습니다. 서로의 코드를 공유하고 가장 설득력 있는 코드를 기반으로 수정했습니다. 직접 실험해보며 생각을 정리할 수 있고 다른 사람에게도 코드를 보여주면서 설명할 수 있었습니다. 그리고 관점이 달라서 내가 생각하지 못하고 넘어갔던 부분들을 다시 볼 수 있었습니다.

2일 동안 리팩토링을 진행하면서 아직은 제 자신의 리팩토링 기준을 정하지 못해서 애매한 부분들이 있지만 어제보다는 나아지는 것을 느낄 수 있었습니다. 그렇지만 남은 기간동안 함수 기능 분리에 대한 기준을 어떻게 할 것인지, 함수가 하는 하나의 일이 어디까지인지, 모듈 분리의 기준은 어떻게 해야하는지에 대해서 꾸준히 생각해봐야겠습니다. 강사님 말씀처럼 계속해서 좋은 코드에 대한 생각을 해야겠습니다. 그리고

**코드 한줄에도 이유가 있어야한다**

는 말을 명심하겠습니다.
