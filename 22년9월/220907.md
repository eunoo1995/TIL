# 📖 딥다이브 복습 러버덕

````markdown
## 객체 리터럴

### 객체란?

- 다양한 타입의 값을 하나의 단위로 구성한 복합적인 자료구조
- 객체는 0개 이상의 프로퍼티(key : value)로 구성된 집합

> 원시값은 별경 불가능한 값이지만 객체는 변경 가능한 값이다.

- 모든 값은 객체의 프로퍼티 값이 될 수 있다.

```jsx
let object = {
  num: 0, // 프로퍼티
  increase: function () {
    // 메서드
    this.num++;
  },
};
```
````

객체의 상태를 나타내는 값 (프로퍼티) 와 프로퍼티를 참조하고 조작할 수 있는 동작(메서드)로 구성되어

상태와 동작을 하나의 단위로 구조화 할 수 있어 유용하다.

### 객체 리터럴에 의한 객체 생성

자바스크립트는 클래스 기반 언어(new 와 함께 생성자를 호출하여 인스턴스 생성)와 달리

프로토타입 기반 언어로서 다양한 객체 생성 방법을 지원한다.

> 객체 리터럴, Object 생성자 함수, 생성자 함수, Object.create 메서드, 클래스(ES6)

객체 리터럴은 {} 내에 0개 이상의 프로퍼티를 정의하고, 변수에 할당되는 시점에 해석되어 생성된다.

```jsx
let person = {
  name: "Lee",
  sayHello: function () {
    console.log(`Hello! My name is ${this.name}.`);
  },
};
let empty = {};
```

객체 리터럴은 자바스크립트의 유연한과 강력함을 대표하는 객체 생성 방식이다.

클래스 정의와 new 호출 없이 리터럴로 객체를 생성한다.

### 프로퍼티

key : value 로 구성된다.

key는 빈 문자열을 포함한 모든 문자열과 심벌 값을 사용 가능

- 식별자 네이밍 규칙을 따르는 경우 ‘ ’ 생략 가능
- 따르지 않는 경우 반드시 ‘ ’ 따옴표를 사용

```jsx
let person = {
  firstName: "anna",
  "last-name": "jo",
};

// 프로퍼티 키를 중복 선언하면 나중에 선언 된 것으로 덮어쓴다.
let foo = {
  name: "lee",
  name: "kim",
};

console.log(foo); // {name: 'kim'}
```

value는 자바스크립트의 모든 값을 사용 가능

### 메서드

자바스크립트의 함수는 일급 객체이다. 따라서 값으로 취급되므로 프로퍼티 값으로 사용 가능하다.

프로퍼티의 값이 함수일 경우 일반함수와 구별을 위해 메서드라 부른다.

```jsx
let circle = {
  radius: 5,
  getDimeter: function () {
    return 2 * this.radius;
  },
};
console.log(circle.getDimeter()); // 10
```

### 프로퍼티 접근

프로퍼티에 접근하는 방법

- 마침표 표기법 object.key
- 대괄호 표기법 object[key] (key는 반드시 ‘’로 감싼 문자열이여야 한다)
- 객체의 존재하지 않는 프로퍼티에 접근하면 undefined를 반환한다. 에러 발생 x

### 프로퍼티 값 갱신

- 이미 존재하는 프로퍼티 값에 값을 할당하면 프로퍼티에 값이 갱신된다.

### 프로퍼티 동적 생성

- 존재하지 않는 프로퍼티에 값을 할당하면 프로퍼티가 동적으로 생성되어 값이 할당된다.

### 프로퍼티 삭제

delete 연산자는 객체의 프로퍼티를 삭제한다. 존재하지 않는 프로퍼티를 삭제하면 에러 없이 무시된다.

## 원시 값과 객체의 비교

자바스크립트의 데이터 타입은 **원시 타입**, **객체 타입**으로 구분할 수 있다.

### 원시 값

- 원시 값은 읽기 전용의 값으로서 변경 불가능한 값이다.

```jsx
const 키워드는 재할당이 금지된 변수이다.

const o = {};

const 키워드를 사용해 선언한 변수에 할당한 원시값은 변경할 수 없다.
하지만 const 키워드를 사용해 선언한 변수에 할당한 객체는 변경할 수 있다.
o.a = 1;
console.log(o); // {a: 1}
```

재할당 시 새로운 메모리 공간을 확보하고 재할당한 값을 저장한 후, 참조하던 메모리 공간의 주소를 변경하는 불변성의 특징을 갖는다. 불변성을 갖는 원시 값을 할당한 변수는 재할당 이외에 변수 값을 변경할 수 있는 방법이 없다.

- 문자열과 불변성

문자열 타입은 1개의 문자당 2바이트의 공간이 필요하여 몇 개의 문자로 이루어졌느냐에 따라 메모리 공간의 크기가 결정된다. 또한 유사 배열 객체이면서 이터러블이므로 배열과 유사하게 각 문자에 접근 가능

> - 유사 배열 객체
>
> 마치 배열처럼 인덱스로 프로퍼티 값에 접근할 수 있고 length 프로퍼티를 갖는 객체를 의미한다.

```jsx
let str = "string";

console.log(str[0]); // s
console.log(str.length); // 6

// 원시 값인 문자열은 변경할 수 없다. 이 때 오류가 발생하지 않고 무시
str[0] = "S";
console.log(str); // string
```

- 값에 의한 전달

> 변수에 원시 값을 갖는 변수를 할당하면 할당받는 변수에 할당되는 변수의 원시 값이 복사되어 전달된다. 이를 **값에 의한 전달**이라고 한다. 이렇게 생성된 변수 값과 할당된 변수값은 각각 다른 공간에 저장된 별개의 값이다. 때문에 서로 간섭할 수 없다.

### 객체

- 객체는 변경 가능한 값이다.

객체를 할당한 변수의 메모리 주소로 접근하면 참조 값에 접근할 수 있다.

참조값은 생성된 객체가 저장된 메모리 공간의 주소, 그 자체다.

원시 값을 할당한 변수는 변수는 O 값을 갖는다. 라고 표현하는 반면

객체를 할당한 변수는 ‘변수는 객체를 참조하고 있다.’ 라고 표현한다.

> 재할당 없이 동적으로 프로퍼티를 추가, 삭제, 갱신할 수 있다.

> 여러개의 식별자가 하나의 객체를 공유할 수 있는 부작용이 발생

## 함수

### 함수란?

> 함수는 자바스크립트의 가장 중요한 핵심 개념이다.
>
> 스코프, 텍스트, 클로저, 생성자 함수,메서드, this, 프로토타입, 모듈화 등이
>
> 모두 함수와 깊은 관련이 있다.
>
> **일련의 과정을 문으로 구현하고 코드 블록으로 감싸서 하나의 실행 단위로 정의한 것이다.**

### 함수를 사용하는 이유

함수는 몇 번이든 호출할 수 있으므로 코드의 재사용 측면에서 매우 유용하다.

코드의 중복을 억제하고 재사용을 높이는 함수는 유지보수의 편의성과 코드의 신뢰성을 높이는 효과

> 함수 또한 변수명과 같이 적절한 이름을 지어 코드의 가독성을 향상시킬 수 있다.

### 함수 리터럴

> 자바스크립트에서 함수는 객체 타입의 값이다.

```jsx
let func = function add(x, y) {
  return x + y;
};

// 함수 이름, 매개변수 목록, 함수 몸체로 구성되어 있다.
```

함수는 일반 객체와 달리 호출을 할 수 있다.

### 함수 정의

> 함수를 정의하는 방법으로 선언문, 표현식, 생성자 함수, 화살표 함수 4가지가 있다.

- **함수 선언문**
  - 함수 선언문은 이름을 생략할 수 없다.
  - 함수 선언문은 표현식이 아닌 문이다.
  - 선언문으로 선언된 함수는 엔진이 생성된 함수를 호출하기 위한 식별자를 함수 이름과 동일한 이름으로 암묵적으로 생성하고 거기에 함수 객체를 할당한다.
  - 함수는 함수 이름이 안닌 식별자로 호출한다.
- **함수 표현식**
  - 자바스크립트의 함수는 값의 성질을 갖는 일급 객체이다.
  - 객체이기 때문에 함수 리터럴로 생성한 함수 객체를 변수에 할당할 수 있다.
  - 표현식의 함수 리터럴은 함수 이름을 생략하는 것이 일반적이다.
  - 함수 이름은 함수 내부에서만 유효한 식별자이므로 이름으로 호출할 수 없다.
- **함수의 생성 시점과 함수 호이스팅**
  - 선언문으로 생성된 함수는 표현식이 아닌 문으로 런타임 이전에 생성되어 호이스팅이 발생해 하단에 선언하여도 선두로 끌어 올려진 것 처럼 함수를 사용할 수 있다.
  - 표현식으로 생성되는 함수는 변수가 먼저 생성된 후 런타임에 식을 평가하여 만들어진 객체를 변수에 할당하므로 변수 호이스팅이 발생한다.
    > 함수 선언문은 호이스팅을 발생시켜 혼란을 야기하므로 표현식을 사용할 것을 권장한다.
- **Function 생성자 함수**
  - 빌트인 생성자 함수에 매개변수 목록과 함수 몸체를 ‘문자열'로 전달하여 new 연산자와 함께 호출하면 함수 객체를 생성하여 반환한다. new 생략 가능
  - 클로저를 생성하지 않는 등 일반적이지 않게 동작한다.
- **화살표 함수**
  - 화살표 함수는 항상 익명 함수, 표현이 간략해진 만큼 내부 동작 또한 간략화 되었다.
  - 생성자 함수로 사용 불가, this 바인딩, prototype과 arguments 객체가 존재하지 않는다.

### 함수 호출

- **매개변수와 인수**
  - 함수 외부에서 내부로 값을 전달할 경우, 매개변수를 통해 인수를 전달한다.
  - 인수는 값으로 평가될 수 있는 표현식이어야 하고, 개수와 타입에 제한이 없다.
- **인수 확인**
  - 매개변수와 인수의 개수 일치 확인하지 않는다 / 매개변수 기본값을 사용해 간소화 가능
  - 매개변수의 타입을 미리 지정할 수 없다. 함수 내부에서 체크 또는 타입스크립트 사용
- **매개변수의 최대 개수**
  - 이상적인 매개변수의 개수는 0개이며 적을수록 좋다. 매개변수가 많다는 것은 하는 일이 많다는 것으로 바람직하지 않다. 이상적인 함수는 한 가지 일만 해야 하며 가급적 작게 만들어야 한다.
  - 매개변수가 3개 이상이 되는 경우 객체를 인수로 전달하는 것이 좋다. 매개변수의 순서를 고려할 필요가 없고 프로퍼티 키를 사용하게 되므로 가독성도 좋아진다. 하지만 부수 효과가 발생할 수 있어 주의가 필요하다.
- **반환문**
  - return 키워드와 반환값으로 이루어진 반환문을 사용해 함수 외부로 반환할 수 있다.
  - 함수 호출은 표현식이므로 리턴 된 값으로 평가된다.
  - return 뒤에 표현식을 생략하거나, 반환문 전체를 생략할 경우 undefined로 평가된다.

### 참조에 의한 전달과 외부 상태의 변경

- 원시 값의 경우 변경 불가능한 값이므로 함수 내부에서 변경 시 재할당 된 새로운 원시 값으로 교체
- 객체는 변경 가능한 값으로 직접 변경이 가능하므로 부수 효과가 발생하여 추적이 어려워진다.
- 옵저버 패턴 등을 통해 객체를 참조하는 모든 이들에게 변경을 통지하거나 불변 객체를 만들어 사용하여 해결할 수 있다.

### 다양한 함수의 형태

- **즉시 실행 함수**
  - 정의와 동시에 즉시 호출되어 다시 호출할 수 없다.
  - 중복된 변수나 함수 이름의 충돌을 방지할 수 있다.
- **재귀 함수**
  - 재귀 함수는 자기 자신을 호출하는 것이다.
  - 식별자 또는 함수 이름을 사용해 호출할 수 있다.
  - 자기 자신을 무한으로 호출하므로 탈툴 조건을 걸어 빠져나가야 한다.
  - 스택 오버플로의 위험이 있으므로 반복문보다 직관적으로 이해하기 쉬울 때만 사용!
- **중첩 함수**
  - 함수의 내부에 정의된 함수를 중첩 함수 또는 내부 함수라고 부른다.
  - 선언된 함수 내부에서만 호출할 수 있고, 외부 함수를 돕는 헬퍼 함수의 역할을 한다.
- **콜백 함수**
  - 함수의 매개변수를 통해 다른 함수의 내부로 전달되는 함수를 콜백 함수라고 한다.
  - 외부에서 콜백 함수를 전달받은 함수를 고차 함수라고한다.
  - 고차 함수는 콜백 함수를 자신의 일부로 합성하고, 호출 시점을 결정하여 호출한다.
  - 익명 함수 리터럴을 이용해 고차함수의 매개변수로 바로 전달하는 것이 일반적이다.
- **순수 함수와 비순수 함수**
  - 순수 함수는 부수 효과가 없는, 동일한 인수로 동일한 값을 반환하는 함수이다.
  - 비순수 함수는 외부 상태에 의존하거나 외부 상태를 변경하는 함수이다.

# 💥 Todos 실습

- render 함수 내부의 돔 조작 방식이 통일되지 못하고 있다. 여러가지 방식으로 리렌더링
- HTML에 자바스크립트가 종속되었기 때문에 일관성이 결여된다.
- 종속성을 해결하기 위해서는 HTML이 모두 자바스크립트로 동적으로 그려져야 한다.

# 🤯 하루을 마치며…

오늘은 todos v3,4 실습을 진행하였다. HTML에 스크립트가 종속되는 기존 방식에서 벗어나 요소들을 동적으로 그려내서 주도권을 자바스크립트가 가지고, 조건부 렌더링을 수월하게 그려낼 수 있었다. 아직 innerHTML을 사용하여 전체 부분이 렌더링이 되는 문제는 남아있지만, 어플리케이션의 큰 흐름을 이해하고 모듈로 분리하여 한 방향으로 흘러가는 컴포넌트를 구성하는 연습을 하고있는 것 같다. 아직 좋은 코드를 작성하기 위해 어떤 부분을 고려해야 하는가에 대한 판단이 재대로 서지 않지만 투두를 계속 반복해보면서 좋은 코드에 대한 고민을 하면서 작성해나가야겠다!
