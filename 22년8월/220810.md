# 📖 오늘의 학습

## 타입 변환과 단축 평가

### 타입 변환이란?

- 자바스크립트의 모든 **값**에는 타입이 존재
- **명시적 타입변환** or **타입 캐스팅**
  - 개발자가 의도적으로 타입을 변환시키는 것
- **암묵적 타입 변환** or **타입 강제 변환**
  - 표현식을 평가하는 도중에 자바스크립트 엔진에 의해 암묵적으로 타입 변환되는 것
- 자바스크립트의 특성 상 원시 값을 직접 변경시키는 것이 아닌 새로운 원시값을 생성한다.
- 생성된 원시값은 재할당 되는 것이 아닌 단 한번만 사용되고 버려진다.
- 무조건 명시적인 변환이 옳다는 논리는 옳지 않다. 중요한 것은 타입 변환이 어떻게 동작하는지 예측할 수 있어야 한다는 것이다.

### 암묵적 타입 변환

- 문맥에 부합하지 않을 때 암묵적 타입 변환 발생 / 문자열, 숫자, 불리언과 같은 원시타입 중 하나로 자동 변환
- 문자열 타입으로 변환
  피연산자 중 하나 이상이 문자열일 경우 + 는 문자열 연결 연산자로 동작한다.
  ```jsx
  let num = 1;
  num + ""; // '1'
  ```
- 숫자 타입으로 변환
  사용된 연산자가 산술 연산자일 경우 모든 피연산자는 문맥상 숫자 타입이여야 한다.
  숫자 타입으로 암묵적 타입 변환하고 숫자 타입으로 변환할 수 없는 경우 연산 수행이 불가능 하므로 NaN으로 평가된다.
  ```jsx
  1 - "1"; // 0
  1 * "10"; // 10
  1 / "일"; // NaN
  ```
  비교 연산자의 역할은 불리언 값을 만드는 것이다.
  피연산자의 크기를 비교하므로 문맥상 모든 피연산자는 숫자 타입이어야 한다.
  ```jsx
  "10" > 2; // true
  ```
  단항 연산자 + 는 피연산자가 숫자 타입이 아닐 경우 암묵적으로 타입 변환을 수행한다.
  ```jsx
  빈문자열 '', 빈 배열 [] // 0
  +true // 1
  +false // 0
  +null // 0
  +undefined, +{}, [10] // NaN
  ```
- 불리언 타입으로 반환
  자바스크립트 엔진은 불리언 타입이 아닌 값을 Truthy(참으로 평가되는 값)과 Falsy(거짓으로 평가되는 값) 으로 구분하고 true, false로 암묵적 타입 변환 한다.
  ### Falsy
  ```jsx
  false
  undefined
  null
  0, -0
  NaN
  ''(빈 문자열)
  ```
  ### truthy
  ```jsx
  true
  '0' (빈 문자열이 아닌 문자열)
  []
  {}
  ```

### 명시적 타입 변환

- 빌트인 생성자 함수를 new 키워드 없아 호출하는 방법, 빌트인 메서드를 사용하는 방법, 암묵적 타입 변환을 이용하는 방법이 있다.
- 문자열 타입으로 변환
  ```jsx
  String 생성자 함수를 new 연산자 없이 호출하는 방법

  String(1) // '1'
  String(NaN) // 'NaN'
  String(Infinity) // 'Infinity'

  toString() 메서드를 사용하는 방법

  (1).toString(); // '1'
  (NaN).toString(); // 'NaN'

  1 + ''; // '1'
  ```
- 숫자 타입으로 변환
  ```jsx
  Number 생성자 함수를 new 연산자 없이 호출하는 방법

  Number('0'); // 0
  Number(true); // 1

  parseInt, parseFloat 함수를 사용하는 방법(문자열만 변환 가능)

  parseInt('0'); // 0
  parseFloat('10.53'); // 10.53

  단항 산술 연산자를 이용하는 방법

  +'0' // 0
  +true // 1

  * 산술 연산자를 이용하는 방법

  '0' * 1; // 0
  '10.53' * 1 // 10.53
  false  * 1 // 0
  ```
- 불리언 타입으로 변환
  ```jsx
  Boolean 생성자 함수를 new 연산자 없이 호출하는 방법
  // 문자열 타입 => 불리언 타입
  Boolean('x'); // true
  Boolean('false'); // true
  Boolean(''); // false 빈 문자열은 false로 반환
  // 숫자 타입 => 불리언 타입
  Boolean(0); // false
  Boolean(1); // true
  Boolean(NaN); // false
  Boolean(Infinity); // true
  // null 타입 => 불리언 타입
  Boolean(null); // false
  // undefined => 불리언 타입
  Boolean(undefined); // false
  // 객체 타입 => 불리언 타입
  Boolean({}); // true
  Boolean([]); // true

  !부정 논리 연산자를 두 번 사용하는 방법
  !!'a' // true
  !!0 // false
  !!NaN // false
  ```

### 단축 평가

표현식을 평가하는 도중 결과가 확정된 경우 나머지 평가 과정을 생락햐는 것

- 논리 연산자를 사용한 단축 평가
  논리합(||)과 논리곱(&&) 연산자 표현식은 언제나 2개의 피연산자 중 한쪽으로 평가
  논리 연산의 결과를 결정하는 피연산자를 타입 변환 없이 그대로 반환한다.
- 옵셔널 체이닝 연산자
  ES11에 도입된 옵셔널 체이닝 연산자 ?.는 좌항이 null 또는 undefined일 경우
  undefined를 반환하고, 아니라면 우항의 프로퍼티 참조를 이어간다.
  ```jsx
  let elem = null;
  let value = elem?.value;
  console.log(value); // undefined
  ```
  옵셔널 체이닝 연산자는 좌항이 falsy 값이라도 null, undefined가 아니라면 우항 프로퍼티 참조를 이어간다.
  ```jsx
  let str = "";
  let length = str?.length;
  console.log(length); // 0
  ```
- null 병합 연산자
  ES11에서 도입된 null 병합 연산자는 ?? 좌항이 null이면 우항을 반환하고, 아니라면 좌항을 반환
  ```jsx
  let foo = null ?? "default string";
  console.log(foo); // 'default string'
  ```
  null 병합 연산자는 좌항이 falsy 값이라도 null, undefined가 아니라면 우항 프로퍼티 참조를 이어가고, 아니라면 좌항을 반환
  ```jsx
  let foo = "" ?? "default string";
  console.log(foo); // ''
  ```

## 객체 리터럴

### 객체란?

- 다양한 타입의 값을 하나의 단위로 구성한 복합적인 자료구조
- 객체는 0개 이상의 프로퍼티(key : value)로 구성된 집합

> 원시값은 별경 불가능한 값이지만 객체는 변경 가능한 값이다.

- 모든 값은 객체의 프로퍼티 값이 될 수 있다.

```jsx
let object = {
  num: 0, // 프로퍼티
  increase: function () {
    // 메서드
    this.num++;
  },
};
```

객체의 상태를 나타내는 값 (프로퍼티) 와 프로퍼티를 참조하고 조작할 수 있는 동작(메서드)로 구성되어

상태와 동작을 하나의 단위로 구조화 할 수 있어 유용하다.

### 객체 리터럴에 의한 객체 생성

자바스크립트는 클래스 기반 언어(new 와 함께 생성자를 호출하여 인스턴스 생성)와 달리

프로토타입 기반 언어로서 다양한 객체 생성 방법을 지원한다.

> 객체 리터럴, Object 생성자 함수, 생성자 함수, Object.create 메서드, 클래스(ES6)

객체 리터럴은 {} 내에 0개 이상의 프로퍼티를 정의하고, 변수에 할당되는 시점에 해석되어 생성된다.

```jsx
let person = {
  name: "Lee",
  sayHello: function () {
    console.log(`Hello! My name is ${this.name}.`);
  },
};
let empty = {};
```

객체 리터럴은 자바스크립트의 유연한과 강력함을 대표하는 객체 생성 방식이다.

클래스 정의와 new 호출 없이 리터럴로 객체를 생성한다.

### 프로퍼티

key : value 로 구성된다.

key는 빈 문자열을 포함한 모든 문자열과 심벌 값을 사용 가능

- 식별자 네이밍 규칙을 따르는 경우 ‘ ’ 생략 가능
- 따르지 않는 경우 반드시 ‘ ’ 따옴표를 사용

```jsx
let person = {
  firstName: "anna",
  "last-name": "jo",
};

// 프로퍼티 키를 중복 선언하면 나중에 선언 된 것으로 덮어쓴다.
let foo = {
  name: "lee",
  name: "kim",
};

console.log(foo); // {name: 'kim'}
```

value는 자바스크립트의 모든 값을 사용 가능

### 메서드

자바스크립트의 함수는 일급 객체이다. 따라서 값으로 취급되므로 프로퍼티 값으로 사용 가능하다.

프로퍼티의 값이 함수일 경우 일반함수와 구별을 위해 메서드라 부른다.

```jsx
let circle = {
  radius: 5,
  getDimeter: function () {
    return 2 * this.radius;
  },
};
console.log(circle.getDimeter()); // 10
```

### 프로퍼티 접근

프로퍼티에 접근하는 방법

- 마침표 표기법 object.key
- 대괄호 표기법 object[key] (key는 반드시 ‘’로 감싼 문자열이여야 한다)
- 객체의 존재하지 않는 프로퍼티에 접근하면 undefined를 반환한다. 에러 발생 x

### 프로퍼티 값 갱신

- 이미 존재하는 프로퍼티 값에 값을 할당하면 프로퍼티에 값이 갱신된다.

### 프로퍼티 동적 생성

- 존재하지 않는 프로퍼티에 값을 할당하면 프로퍼티가 동적으로 생성되어 값이 할당된다.

### 프로퍼티 삭제

delete 연산자는 객체의 프로퍼티를 삭제한다. 존재하지 않는 프로퍼티를 삭제하면 에러 없이 무시된다.

## 원시 값과 객체의 비교

자바스크립트의 데이터 타입은 **원시 타입**, **객체 타입**으로 구분할 수 있다.

### 원시 값

- 원시 값은 읽기 전용의 값으로서 변경 불가능한 값이다.

```jsx
const 키워드는 재할당이 금지된 변수이다.

const o = {};

const 키워드를 사용해 선언한 변수에 할당한 원시값은 변경할 수 없다.
하지만 const 키워드를 사용해 선언한 변수에 할당한 객체는 변경할 수 있다.
o.a = 1;
console.log(o); // {a: 1}
```

재할당 시 새로운 메모리 공간을 확보하고 재할당한 값을 저장한 후, 참조하던 메모리 공간의 주소를 변경하는 불변성의 특징을 갖는다. 불변성을 갖는 원시 값을 할당한 변수는 재할당 이외에 변수 값을 변경할 수 있는 방법이 없다.

- 문자열과 불변성

문자열 타입은 1개의 문자당 2바이트의 공간이 필요하여 몇 개의 문자로 이루어졌느냐에 따라 메모리 공간의 크기가 결정된다. 또한 유사 배열 객체이면서 이터러블이므로 배열과 유사하게 각 문자에 접근 가능

> - 유사 배열 객체
>
> 마치 배열처럼 인덱스로 프로퍼티 값에 접근할 수 있고 length 프로퍼티를 갖는 객체를 의미한다.

```jsx
let str = "string";

console.log(str[0]); // s
console.log(str.length); // 6

// 원시 값인 문자열은 변경할 수 없다. 이 때 오류가 발생하지 않고 무시
str[0] = "S";
console.log(str); // string
```

- 값에 의한 전달

> 변수에 원시 값을 갖는 변수를 할당하면 할당받는 변수에 할당되는 변수의 원시 값이 복사되어 전달된다. 이를 **값에 의한 전달**이라고 한다. 이렇게 생성된 변수 값과 할당된 변수값은 각각 다른 공간에 저장된 별개의 값이다. 때문에 서로 간섭할 수 없다.

### 객체

- 객체는 변경 가능한 값이다.

객체를 할당한 변수의 메모리 주소로 접근하면 참조 값에 접근할 수 있다.

참조값은 생성된 객체가 저장된 메모리 공간의 주소, 그 자체다.

원시 값을 할당한 변수는 변수는 O 값을 갖는다. 라고 표현하는 반면

객체를 할당한 변수는 ‘변수는 객체를 참조하고 있다.’ 라고 표현한다.

> 재할당 없이 동적으로 프로퍼티를 추가, 삭제, 갱신할 수 있다.

> 여러개의 식별자가 하나의 객체를 공유할 수 있는 부작용이 발생

# 💥 부족한 / 몰랐던 점

- 명시적 타입 변환 안에 왜 암묵적 타입 변환이 포함되는가?
- {}, [] 는 truthy 값인데 []의 숫자 타입은 0이고 0 은 false?
- 표현식에 사용되어진 값은 os 영역의 메모리 셀의 값 저장 cpu가 가져와서 연산
- 값은 타입을 가지고 있고 cpu는 그 타입을 알고있다. 문맥에 오점이 있을 경우 언어의 해석에 달려있다.
- 자바스크립트의 탄생 목적은 아주 경량의 프로그램 언어에 대한 필요(웹사이트의 단순한 기능을 위해)
- 초기엔 언어의 타겟이 단순한 로직을 짤 수 있는 비프로그래머로 설정되어 에러발생을 최소화(실행 정지 방지)시키고 정상작동하는 것이 중요한 핵심이었다. NaN 같은 특이한 것이 왜 탄생하였을까?
- 컨셉에 따라 에러 발생을 시키지 않기 위해 NaN이 탄생하게 되었다.
- - 라는 토큰을 만나면 함수를 호출하는 것이다. 함수에 좌항과 우항을 주고 타입을 확인하여 둘 다 숫자면 연산, 둘 중 하나라도 문자면 문자열 연결로 동작
- 객체 관리 방식 (히든 클래스 방식이 무엇일까?)

# 🤯 하루을 마치며…

오늘은 처음으로 러버덕을 진행해보았다. 서로 공부한 내용을 바탕으로 생각을 정리하고 발표를 진행하면서 서로 의견을 나눌 때, 내가 공부할 때 보지 못했던 내용들도 알게 되었고 말을 하며 지식이 더 잘 정리되는 느낌을 받았다. 남은 기간 책에 대한 학습을 진행할 때, 양도 많고 시간이 많이 촉박하지만 자는 시간을 더 줄여서라도 이 책을 온전히 습득하기 위해 의식적인 연습과 반복을 통해 차곡차곡 쌓아올려야겠다고 생각했다. 온라인으로 진행하는 만큼 집중력이 흐트러질 때마다 다시 다잡고 집중해서 열심히 해야겠다!!!!!
