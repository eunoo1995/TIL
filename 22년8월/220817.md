# 📖 오늘의 학습

## 프로토타입

### 객체 지향 프로그래밍

> 절차 지향적인 관점에서 벗어나 객체의 집합으로 프로그래밍 하는 것

실체를 인식하는 사고를 프로그래밍에 접목한다. 실체는 특징이나 성질을 나타내는 **속성**을 가지고 있고 이를 통해 인식하거나 구별할 수 있다. 사람이라는 실체의 나이 몸무게 키 이름 등 다양한 속성들 중 나이와 이름만 가지고 사람을 구현하려고 추려내어 표현하는 것을 **추상화**라고 한다.

객체는 상태를 나타내는 프로퍼티와 동작을 나타내는 메서드를 모아놓은 복합적인 자료구조이다.

### 상속과 프로토타입

> 상속은 객체 지향의 핵심, 프로토타입 기반으로 상속을 구현하여 불필요한 중복 제거 가능

생성자 함수를 통해 인스턴스를 생성할 때 일반적으로 값을 저장하는 프로퍼티의 경우 인스턴스마다 다른 값을 가진다. 하지만 메서드의 경우 모든 인스턴스가 같은 메서드를 사용하므로 생성자 내부에 메서드를 만들 경우 매번 인스턴스가 생길 때 마다 중복된 메서드를 가지게 된다. 이런 불필요한 메모리의 낭비와 함수 생성 과정을 방지하기 위해 프로토타입을 통한 상속을 구현한다.

### 프로토타입 객체

> 어떤 객체의 상위(부모) 역할을 하는 객체로서 공유 프로퍼티를 제공한다.

모든 객체는 하나의 프로토타입을 갖고, 생성자 함수와 연결되어 있다.

- ****proto** 접근자 프로퍼티**
  모든 객체는 **proto**를 사용해 자신의 프로토타입에 간접적으로 접근할 수 있다.
  객체가 직접 소유하는 프로퍼티가 아닌 Object.prototype의 프로퍼티이다.
  스코프와 마찬가지로 양방향으로 가리킬 경우 무한루프에 빠지므로 접근자 프로퍼티를 통해 접근하고 교체할 수 있도록 구현되어 있다.
  코드 내에서 직접 사용하는 것은 권장되지 않는다. 직접 상속을 통해 상속한 객체는 **proto**를 상속받지 못하기 때문이다. 따라서 Object.getPrototypeOf()와 Object.setPrototypeOf()의 사용을 권장한다.

```jsx
const test = {};
Object.getPrototypeOf(test); // test.__proto__;
Object.setPrototypeOf(test, { a: 1 }); // test.__proto__ = {a : 1};
```

- **함수 객체의 prototype 프로퍼티**
  함수 객체만이 소유하는 prototype 프로퍼티는 생성자 함수가 생성할 인스턴스의 프로토타입을 가리킨다. 따라서 화살표 함수와 축약 메서드는 prototype 프로퍼티를 소유하지 않고 프로토타입을 생성하지도 않는다.
  객체의 **proto** 접근자 프로퍼티와 함수 객체가 가지고 있는 prototype은 결국 동일한 프로토타입을 가리킨다.
- **프로토타입의 constructor 프로퍼티와 생성자 함수**
  모든 프로토타입은 constructor 프로퍼티를 갖는다. 이 프로퍼티는 자신을 prototype로 참조하고 있는 생성자 함수를 가리킨다. 이 연결은 함수가 생성될 때, 즉 함수 객체가 생성될 때 이뤄진다.

### 리터럴 표기법에 의해 생성된 객체의 생성자 함수와 프로토타입

> 리터럴 표기법과 같이 new 연산자 없이 인스턴스를 생성하는 객체 생성 방식도 있다.

리터럴 표기법으로 생성된 객체의 경우 constructor 프로퍼티가 가리키는 생성자 함수가 반드시 객체를 생성한 생성자 함수라고 단정할 수 없다.

객체 리터럴로 생성된 객체는 생성자 함수에 의해 생성된 객체는 아니지만, 큰 틀에서 보면 생성자 함수로 생성된 객체와의 큰 차이가 없다. 따라서 프로토타입의 constructor와 연결된 생성자 함수를 리터럴 표기법으로 생성한 객체의 생성자 함수로 생각해도 된다.

### 프로토타입의 생성 시점

> 프로토타입은 함수가 생성되는 시점에 더불어 생성된다. 생성자 함수와 프로토타입은 쌍으로 존재

- 사용자 정의 생성자 함수의 프로토타입
  constructor 함수가 평가되어 생성될 때 프로토타입도 함께 생긴다.
  생성된 프로토타입은 constructor 프로퍼티만 가지고, 자신도 객체이므로 Object의 프로토타입을 상속받는다.
- 빌트인 생성자 함수의 프로토타입
  빌트인 생성자 함수는 전역 객체가 생성되는 시점에 생성되고, 이 때 프로토타입도 같이 생성된다.

### 객체 생성 방식과 프로토타입의 결정

> 객체를 생성하는 다양한 방식은 OrdinaryObjectCreate 추상 연산을 통해 생성된다.

- 객체 리터럴로 생성한 객체
  객체 리터럴이 평가되면 추상 연산에 의해 Object 생성자 함수와 그 프로토타입과 연결된다.
- Object 생성자 함수로 생성한 객체
  인수 없이 호출하여 생성할 경우 빈 객체를 반환하고, 그 객체는 Object 생성자 함수와 프로토타입과 연결된다. 리터럴 방식과의 차이는 프로퍼티를 추가하는 방식이 다르다.
- 사용자 정의 생성자 함수로 생성한 객체
  동일하게 추상 연산 OrdinaryObjectCreate을 호출하고, 생성자 함수의 prototype에 연결된 객체를 프로토타입으로 전달한다. 해당 프로토타입에 프로퍼티를 추가하여 모든 인스턴스가 공유 할 수 있는 상속을 구현할 수 있다.

### 프로토타입 체인

> 자바스크립트는 객체의 프로퍼티에 접근하려고 할 때 해당 객체에 접근하려는 프로퍼티가 없다면 [[prototype]] 내부 슬롯의 참조를 따라 자신의 부모 역할을 하는 프로토타입의 프로퍼티를 순차적으로 검색한다. 이를 프로토타입 체인이라고 한다. 상속을 구현하는 메커니즘이다.

스코프 체인과 프로토타입 체인은 서로 협력하여 식별자와 프로퍼티를 찾는데 사용된다.

### 오버라이딩과 프로퍼티 섀도잉

> 프로토타입과 같은 이름의 프로퍼티를 추가할 경우 프로토타입의 값이 바뀌는 것이 아닌 인스턴스의 프로퍼티로 추가된다. 이를 통해 오버라이딩을 할 수 있고, 부모 프로퍼티는 섀도잉이 발생한다.

인스턴스 객체를 통해 프로토타입의 프로퍼티를 변경 또는 삭제할 수 없다.

### 프로토타입의 교체

> 프로토타입은 임의의 다른 객체로 변경할 수 있다. 동적으로 변경 가능

- 생성자 함수에 의한 프로토타입의 교체
  생성자 함수의 prototype 프로퍼티에 직접 객체를 넣어준 경우 constructor 프로퍼티가 존재하지 않으므로 교체된 객체의 부모인 Object의 constructor가 호출되어 Object가 나온다.
  교체할 객체 내에 constructor 프로퍼티를 직접 추가하여 연결을 살려낼 수 있다.
- 인스턴스에 의한 프로토타입의 교체
  인스턴스의 **proto**를 사용하여 프로토타입을 교체하는 경우 이미 생성된 인스턴스의 프로토타입을 교체하는 것이다. Object.setProtoTypeOf(객체, 부모객체)로 프로토타입을 교체할 수 있다.

프로토타입의 교체를 통해 객체의 상속 관계를 동적으로 변경하는 것은 번거로우므로 직접 교체하지 않는 것이 좋다. 직접 상속을 사용하는 것이 좋다.

### instanceof 연산자

> 이항 연산자로서 좌변에 객체 식별자, 우변에 생성자 함수 식별자를 피연산자로 받는다.

프로토타입 체인에 존재는지를 확인하고 boolean을 반환하므로 cunstructor의 연결과 상관없이

동작한다. 인스턴스에서 직접 프로토타입을 바꾸지 않는 한 체인은 끊어지지 않는다.

### 직접 상속

> Object.create(프로토타입 객체[, {프로퍼티 키 : 디스크립터 객체}]);

위 메서드를 사용할 경우 new 연산자 없이 객체 생성이 가능하고, 프로토타입을 직접 지정하면서 객체를 만들 수 있다. 첫번째 인자에 null을 넣어 생성하면 Object.prototype을 상속받지 않는, 프토로타입에 종점에 있는 객체가 생성되므로 Object가 가지고 있는 메서드는 직접 호출하는 것 보다 간접 호출로 사용하는 것이 권장된다.

ES6에선 객체 내부에서 **proto**를 이용하여 직접 상속을 구현할 수 있다.

### 정적 프로퍼티 / 메서드

> 생성자 함수로 인스턴스를 생성하지 않아도 참조/호출 할 수 있는 프로퍼티를 말한다.

생성자 함수 또한 객체이므로 자기 자신의 프로퍼티를 가질 수 있다.

### 프로퍼티 존재 확인

1. in 연산자

   key in object 를 이용해 존재 여부를 확인할 수 있다.

   확인 대상뿐만 아니라 모든 프로토타입의 프로퍼티를 확인하므로 주의가 필요하다.

   ES6에서 도입된 Reflect.has(객체,키)를 이용해도 동일하게 동작한다.

2. Object.prototype.hasOwnProperty

   프로토타입 체인을 확인하지 않고 호출한 객체 고유의 프로퍼티인지 확인한다.

### 프로퍼티 열거

- for( let key in 객체) 문
  상속받은 프로퍼티까지 모두 열거한다.
  프로퍼티의 enumerable이 false일 경우 열거할 수 없다.
  for…in문은 열거할 때 순서를 보장하지 않는다. 모던 브라우저는 자체적으로 정렬해준다.
  배열은 in문 사용시 프로퍼티가 출력될 수 있으므로 for of 나 forEach 등을 사용하는 것이 좋다.
- Object.keys/values/entries 메서드
  for…in 문은 상속받은 프로퍼티까지 열거하므로 자신의 프로퍼티인지 확인하는 과정이 추가로 필요하기 때문에 객체 자신의 프로퍼티만 열거하기 위해서는 Object.keys/values/entries를 사용하는 것이 좋다.

## Git 실전

하나의 스프린트 주기가 끝나고 회고는 아주 중요하다.

- **3L 전략 회고**

완벽하게 깃 플로우를 사용한 것은 아니지만 리모트와 로컬 저장소에 대한

이해를 바탕으로 깃의 동작 과정에 대해 어느정도는 이해할 수 있는 시간이었던 것 같다.

협업 과정에서 브랜치를 나누어 작업하고, 배운 커밋 컨벤션을 지키려고 신경쓰면서 깃을

사용하며 지켜야 할 것들에 대해 배울 수 있었고, 프로젝트가 마무리되는 과정에서 수업을

들어서 포크를 하고 각자의 레포에서 깃 플로우를 적용해 작업하지 못한 것이 아쉬웠다!

### 되돌리는 방법

- **mv 이름 변경 (또는 파일 이동)**
  git mv 현재이름 바꿀이름을 통해 변경
  이름을 바꾸면 add할 것이 없으므로 바로 커밋하면 된다.
  파일 위치 이동도 마찬가지이다.
  git 명령 없이 mv만 하면 삭제하고 다시 만드는 동작을 한다.
- **변경사항을 add 전에 원래 상태로 돌아가기**
  최신 커밋으로 돌릴 수 있다.
  git checkout — 파일명 또는 경로 ( 옛날 )
  git restore 파일명 또는 경로
- **add로 스테이징 된 변경사항을 내리는 명령**
  git reset HEAD(최신 상태 커밋) 파일명 또는 경로
  git restore —staged 파일명
  작업단위로 커밋하기 위해 스테이지 상의 파일을 내기리 위하여 사용
  많은 양의 단위일 때는 한번에 add . 으로 올리고 내리면 편함
  git rm -f 파일명 으로 스테이지에서 내리면서 삭제 가능
- **커밋을 수정하는 명령**
  marge 방식이 rebase 방식보다 사람이 많을 때 수월하다.
  rebase 방식은 피쳐를 따온 베이스의 상태변화를 계속 받아와야함
  git commit —amend \*\*\*\*: 직전 커밋 메세지를 수정할 수 있다.
- **커밋을 되돌리는 명령**

1. Reset

   협업 시 내가 삭제해도 다른 사람이 가지고 있을 수 있으므로 근본적인

   해결을 하기 힘들다. 잘못 사용하면 큰 일 난다!!!!!!!

   git reset —hard HEAD~개수로 삭제 후

   `git push -f origin <branch>`

2. Revert

   잘못하기 전 과거로 돌아가 최신을 유지하면서 되돌렸다는 이력을 commit으로

   남겨 모든 팀원이 이 사항을 공유하고 주지시킬 수 있음.

   `git revert --no-commit HEAD~3..`

   `git commit`

   `git push origin <branch>`

   잘못된 행동을 되돌릴 때 돌아가서 커밋 기록을 남길 수 있다.

   —no-commit 없이 사용하면 커밋 단위별로 다시 커밋을 남겨야 한다.

   merge 커밋을 취소하기 위해서는 -m 플래그 사용

# 💥 부족한 부분

공부하고 있는 개념들이 완전히 이해된 느낌보단 추상적으로 이해한 느낌

두루뭉실하게 알고 넘어가지 말고 좀 더 명확하게 내부 동작을 이해할 수 있도록 반복이 필요

깃과 깃허브를 사용한지 좀 됐다고 깃 플로우를 활용한 브랜치 전략 흐름이 헷갈림

# 🤯 하루을 마치며…

어려운 챕터 중 하나인 프로토타입에 대한 학습을 진행하며 이게 어떤 느낌이다 정도로는 이해가 가지만

내부 슬롯이나 리터럴이 평가되는 추상 연산 과정이라던가 명확하게 개념이 이해되지 않는 부분이 있는 것 같다.

이해하지 못한 상태로 넘어가면 또 다시 반복해서 보고 시간을 그만큼 다시 써야하는 만큼 내일 러버덕과 수업 때 애매했던 내용에 대한 개념을 잘 잡고 다음 챕터로 넘어갈 수 있도록 신경써야할 것 같다. 또 깃과 깃허브를 활용하여 역행하는 방법에 대해 배웠다. 모든 개발 과정에서 정상적인 흐름으로 진행되는 것이 베스트기 때문에 항상 커밋을 고민하고 진행하고 push는 정말 확실할 때만 하는 습관을 길러야겠다. 또한 아직 익숙하지 않은 커밋 컨벤션이나 명령들은 좀 더 사용을 자주 하면서 익숙해지도록 앞으로 진행할 프로젝트에 배운 내용을 잘 적용하고 신경써서 사용해야겠다고 생각했다. 학습 진도가 버겁지만 최대한 따라가도록 집중해서 공부해야겠다…
