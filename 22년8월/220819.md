# 📖 오늘의 학습

## this

### this 키워드

> 동작을 나타내는 메서드는 자신이 속한 객체의 프로퍼티를 변경할 수 있어야 한다. 이때 자신이 속한 객체의 프로퍼티를 참조하기 위해 먼저 자신이 속한 객체를 가리키는 식별자를 참조할 수 있어야 함

- this는 자신이 속한 객체 또는 자신이 생성할 인스턴스를 가리키는 자기 참조 변수다.
- this가 가리키는 값, 즉 this 바인딩은 함수 호출 방식에 의해 동적으로 결정된다.

### 함수 호출 방식과 this 바인딩

- **일반 함수 호출**
  일반 함수로 호출하면 함수 내부의 this에는 전역 객체가 바인딩된다.
  strict mode가 적용된 일반 함수 내부의 this는 undefined가 바인딩 된다.
  중첩 함수, 콜백 함수도 일반 함수로 호출 되면 내부의 this에는 전역 객체가 바인딩
- **메서드 호출**
  메서드 내부의 this는 메서드를 호출한 객체, 즉 호출할 때 . 앞에 기술한 객체가 바인딩
  메서드를 소유한 객체가 아닌 호출한 객체가 바인딩된다.
  프로토타입 메서드 내부의 this도 호출한 객체에 바인딩된다.
- **생성자 함수 호출**
  생성자 함수 내부의 this는 미래에 생성할 인스턴스가 바인딩된다.
- **Function.prototype.apply/call/bind 메서드에 의한 간접 호출**
  apply/call 메서드는 함수를 호출한다.
  첫번째 인수로 this로 사용할 객체, 이후는 함수에게 전달할 인수를 넘겨준다.
  대표적인 용도는 arguments 객체와 같은 유사 배열 객체에 배열 메서드를 적용할 때
  bind 메서드는 함수를 호출하지 않고 인자로 준 값으로 this를 바인딩한 함수를 반환한다.

## 실행 컨텍스트

### 소스코드의 타입

- 전역 코드
  전역 코드는 전역 변수 관리를 위해 최상위 스코프인 전역 스코프를 생성한다.
  전역 실행 컨텍스트를 생성한다.
- 함수 코드
  지역 스코프를 생성하고 지역 변수, 매개변수, arguments 객체를 관리하기 위해 함수 실행 컨텍스트를 생성한다.
- eval 코드
  eval 코드는 strict mode에서 자신만의 스코프를 생성한다. 이를 위해 eval 실행 컨텍스트가 생성
- 모듈 코드
  모듈 코드는 모듈별로 독립적인 모듈 스코프를 생성한다. 이를 위해 모듈 실행 컨텍스트 생성

### 소스코드의 평가와 실행

> 모든 소스코드는 실행하기 전 평가 과정을 거치며 실행을 위한 준비를 한다.

### 실행 컨텍스트의 역할

> 코드가 실행되려면 스코프, 식별자, 코드 실행 순서 등의 관리가 필요하다. 실행 컨텍스틑 소스코드를 실행하는 데 필요한 환경을 제공하고 코드 실행 결과를 실제로 관리하는 영역이다. 식별자와 스코프는 렉시컬 환경으로, 실행 순서는 실행 컨텍스트 스택으로 관리한다.

- 선언에 의해 생성된 모든 식별자를 스코프로 구분하여 등록하고 상태 변화를 지속적으로 관리할 수 있어야 한다.
- 스코프는 중첩 관계에 의해 스코프 체인을 형성해야 한다.
- 현재 실행 중인 코드의 실행 순서를 변경할 수 있어야 하며 다시 되돌아갈 수도 있어야 한다.

### 실행 컨텍스트 스택

> 실행 컨텍스트는 스택 자료구조로 관리된다. 이를 실행 컨텍스트 스택이라 부른다.

실행 컨텍스트의 최상위에 존재하는 실행 컨텍스트는 언제나 현제 실행 중인 코드의 실행 컨텍스트다.

따라서 스택의 최상위에 존재하는 실행 컨텍스트를 실행 중인 실행 컨텍스트라고 부른다.

### 렉시컬 환경

> 렉시컬 환경은 식별자와 값 그리고 상위 스코프에 대한 참조를 기록하는 자료구조로 실행 컨텍스트를 구성하는 컴포넌트이다. 렉시컬 환경은 스코프와 식별자를 관리한다.

렉시컬 환경은 두 개의 컴포넌트로 구성된다.

- 환경 레코드
  스코프에 식별자를 등록하고 등록된 식별자에 바인딩된 값을 관리하는 저장소다.
  소스코드의 타입에 따라 차이가 있다.
- 외부 렉시컬 환경에 대한 참조
  상위 스코프를 가리킨다. 이때 상위 스코프란 외부 렉시컬 환경, 즉 해당 실행 컨텍스트를 생성한 소스코드를 포함하는 상위 코드의 렉시컬 환경을 말한다. 단방향 링크드 리스트로 스코프 체인을 구현

# 💥 수업 정리

- 아스키코드는 영어를 변환하는 다양한 코드 변환 방식 중 하나이다.
- 유니코드는 국제적인 코드 변환 규약?
- 많은 나라의 언어를 변환하는 규칙이 유니코드의 표(유니코드 셋)에 담겨있다.
- UTF-8 8비트 → 아스키코드의 8비트 단위(1바이트)와 호환이 좋다.
- 한국어는 3바이트를 체택, 가변적이다. 첫 바이트의 시작에 사용할 바이트를 알려준다.
- 1바이트를 사용하는 영어보다 한글을 사용시 메모리를 많이 차지하게 된다.
- 아스키코드 유니코드에 대해 공부하기
- this는 자바스크립트의 약점같이 복잡하다.
- 재귀적으로 객체를 참조할 경우 객체에 함수가 묶이게 된다. 묶인 객체의 값만 참조 가능(정적 결정)
- 위 문제를 해결하기 위해 this는 호출할 때 동적으로 결정된다.
- 메서드 내부는 방법이라도 있지만 생성자 함수 내부는 미래 시점이기 때문에 대체할 방법이 없다.
- 렉시컬 스코프는 상위 스코프를 결정하는 방식이다.
- 함수는 그냥 함수다.
- 자바스크림트는 함정들이 많아 조심해야한다.
- 메서드를 객체가 가진 함수라고 생각하면 어려워진다. 함수는 객체로 독립적으로 존재한다.
- 중첩 함수와 콜백 함수 내부와 외부 함수의 this의 불일치 문제가 발생한다.
- 중첩 함수의 이유는 외부 함수 안에서만 쓰이고, 여러번 호출이 되기 때문에!!!!!
- 한번만 호출되어도 기능을 묶는 커멘트를 달아주는 느낌으로 함수로 묶는다.
- 커멘트로 주석을 달아 표시할 경우 리팩토링 시 주석까지 고치지 않으므로 문제가 생김
- 가독성의 측면으로 함수를 만드는 경우가 있다.
- 외부 함수가 메서드로 호출, 중첩 함수가 일반 함수로 호출되어 두 함수의 맥락이 달라져버리는 문제
- this의 문제를 해결하기 위해 화살표 함수를 사용한다.
- 화살표 함수는 this를 가지지 않는다.
- 환경 레코드의 this는 식별자처럼 스코프 체인을 통해 찾아간다.
- 콜백 함수는 외부의 로직을 인수로 받아오는 것, 중첩 함수는 내부에서 직접 가지는 것
- 매개변수는 값을 받아들이는 통로, 인수는 밖에서 주는 값
- 콜백 함수는 외부에 정의 된 함수를 인수로 넣어주는 것이기 때문에 밖에서 정의된 상태로 들어간다.
- setTimeout()는 set처럼 설정하지 호출하지 않는다.
- setTimeout는 시간만 알려주고 끝 브라우저가 시간을 재서 함수를 호출시킨다.
- 최고 좋은 방법은 화살표 함수다!!!
- 함수 객체가 생성될 때 몸체의 문들을 블록문으로 가지고 있는다.
- [[call]] 호출이 되면 그 문자열을 평가한다.함수 실행 컨텍스트 생성
- ES6에 나온 메서드 축약표현은 메서드라고 부른다.
- apply, call은 . 앞의 메서드를 호출하는 것이 본질
- bind는 this를 갈아끼우고 함수를 반환하는 것이 본질
- Array.from(유사 배열 객체) 로 배열로 변환
- 클래스에서는 bind를 사용할 경우가 있다.
- 전역 코드는 전역 스코프를 만든다.
- ES6 이전에는 전역 객체가 전역 스코프였다.
- 실행 컨텍스트는 지금까지 배운 모든 것을 가진다.

# 🤯 하루을 마치며…

오늘 진도인 this와 실행 컨텍스트 부분은 역시나 이해하기 어려운 부분이 많았다. 특히 this는 동적으로 결정되는 부분이 많이 헷갈려서 유튜브 영상도 찾아보고 여러가지를 참고해봤지만 온전히 이해되지 않았었는데 수업때 강사님이 해주신 설명으로 납득되지 않았던 부분에 대해 이해했다. 하지만 내가 코드를 작성할 때 배운 내용들을 녹여낼 수 있을지에 대한 고민이 계속 생기는 것 같다. 결국 이건 반복밖에 없는 것 같다. 수업 진도가 마무리 되어도 막히는 부분이 있을 때 반복하고 면접 전에도 일독 해야겠다!
