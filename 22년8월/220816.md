# 📖 오늘의 학습

## 프로퍼티 어트리뷰트

### 내부 슬롯과 내부 메서드

> 자바스크립트 엔진에서 실제로 동작하는 프로퍼티이지만 직접 접근하거나 호출할 수 있는 방법을 제공하지 않는다. 일부에 한해 간접적으로 접글할 수 있는 수단을 제공한다.

### 프로퍼티 어트리뷰트와 프로퍼티 디스크립터 객체

> 엔진은 프로퍼티를 생성할 때 상태를 나타내는 프로퍼티 어트리뷰트를 기본값으로 자동 정의한다.

```jsx
Object.getOwnPropertyDescriptor(객체, "프로퍼티 키");

// 프로퍼티 디스크립터 객체를 반환한다.

Object.getOwnPropertyDescriptors(객체);

// 프로퍼티 디스크립터 객체들을 반환한다.
```

### 데이터 프로퍼티와 접근자 프로퍼티

- **데이터 프로퍼티**
  키와 값으로 구성된 일반적인 프로퍼티이다.
- **접근자 프로퍼티**
  자체적으로 값을 갖지 않고, 호출되는 접근자 함수로 구성된 프로퍼티다.

### 프로퍼티 정의

> Object.defineProperty 메서드를 이용해 프로퍼티의 어트리뷰트를 정의할 수 있다.

### 객체 변경 방지

> Object.defineProperty 또는 Object.defineProperties를 사용해 재정의 할 수 있고, 자바스크립트는 자체적으로 객체의 변경을 방지하는 다양한 메서드를 제공한다.

- 객체 확장 금지 Object.preventExtensions() : 프로퍼티 추가 금지
- 객체 밀봉 Object.seal() : 프로퍼티 추가, 삭제, 재정의 금지 읽기 쓰기 가능
- 객체 동결 Object.freeze() : 프로퍼티 읽기만 가능

> 불변 객체를 만들기 위해서는 재귀를 이용해 중첩 객체들 까지도 동결시켜야 한다.p

## 생성자 함수에 의한 객체 생성

### Object 생성자 함수

> new 연산자와 함께 Object 생성자 함수를 호출하면 빈 객체를 반환한다.

### 생성자 함수

- **객체 리터럴에 의한 객체 생성 방식의 문제점**
  동일한 프로퍼티를 갖는 여러개의 객체를 생성해야 하는 경우 비효율적이다.
- **생성자 함수에 의한 객체 생성 방식의 장점**
  탬플릿처럼 new 키워드와 함께 호출하여 구조가 동일한 객체 여러개를 만들 수 있다.
  new 키워드를 생략하고 호출하면 일반 함수처럼 작동한다.
- **생성자 함수의 인스턴스 생성 과정**
  인스턴스를 생성하고 생성된 인스턴스르 초기화한다.
  new 키워드와 함께 호출하면 암묵적으로 빈 객체를 생성하고 this에 바인딩한다.
  → 코드가 한 줄씩 실행되어 인스턴스를 초기화한다. 프로퍼티나 메서드 추가
  → 모든 내부 코드가 실행 된 후 암묵적으로 this에 바인딩된 객체를 반환한다.
  임의의 객체를 반환하면 this가 반환되지 못한다. 원시 값 반환은 무시 return 생략 권장
- **내부 메서드 [[Call]]과 [[Construct]]**
  함수는 일반 객체와 동일하게 동작하며, 함수 객체만의 내부 슬롯과 메서드도 가진다.
  함수 객체는 호출을 할 수 있어야 하므로 반드시 callable이여야 한다.
  하지만 모든 함수가 constructor는 아니다.
- **constructor 와 non-constructor의 구분**
  - constructor : 함수 선언문, 표현식, 클래스
  - non-constructor : 축약 메서드, 화살표 함수
- **new 연산자**
  constructor인 함수를 new와 함께 호출하여 생성자 함수로 동작하게 한다.
  파스칼 케이스로 작성하여 일반 함수와 구별할 수 있도록 노력한다.
- **new.target**
  생성자 함수가 new 연산자 없이 호출되는 것을 방지하기 위해 지원
  constructor 함수 내부에서 암묵적인 지역 변수와 같이 사용하며 메타 프로퍼티라 부름
  함수 내부의 new.target은 함수 자신을 가리킨다. new 없이 호출하면 undefined
  IE에선 지원하지 않음, 스코프 세이프 생성자 패턴을 통해 검사
  → this가 전역인지 프로토타입 체인에 연결되어 있는지 확인 (this instanceof 생성자함수)
  빌트인 생성자 중 String, Number, Boolean은 new 없이 호출하면 원시 값 반환

## 함수와 일급 객체

### 일급 객체

1. 무명의 리터럴로 생성 가능, 즉 런타임에 생성 가능
2. 변수나 자료구조에 저장할 수 있다.
3. 함수의 매개변수에 전달 가능
4. 함수의 반환값으로 사용할 수 있다.

### 함수 객체의 프로퍼티

- **arguments 프로퍼티**
  전달된 인수들의 정보를 담고 있는 순회 가능한 유사 배열 객체
  함수 내부에서 지역 변수처럼 사용된다.
  매개변수의 개수를 확정할 수 없는 가변 인자 함수를 구현할 때 유용하다.
  ES6 Rest 파라미터의 도입으로 번거로움 해결, 지원하지 않는 경우 arguments 사용
- **caller 프로퍼티**
  비표준 프로퍼티, 함수 자신을 호출한 함수를 가리킨다.(고차 함수?)
- **length 프로퍼티**
  매개변수의 개수를 가리킨다.
- **name 프로퍼티**
  함수의 이름을 나타낸다. 익명함수 ES5 : “”, ES6 : 변수(식별자) 이름
- ****proto** 접근자 프로퍼티**
  모든 객체는 프로토타입 객체를 가리키는 [[prototype]] 내부 슬롯을 갖는다.
  객체 자신의 프로퍼티가 아닌 prototype이 제공하는 접근자 프로퍼티이다.
  간접적으로 프로토타입 객체에 접근할 수 있게 해준다.
- **prototype 프로퍼티**
  생성자 함수로 호출할 수 있는 객체, 즉 constructor만이 소유하는 프로퍼티이다.
  생성자 함수가 생성할 인스턴스의 프로토타입 객체를 가리킨다.

# 💥 수업 정리

- for() 괄호 안의 선언이 블록 밖에 작성되어 있지만 안에 있는 것으로 작동한다. (매개변수도 마찬가지)
- 스코프는 식별자를 어디서 찾느냐이다.
- 변수 선언이란 식별자의 존재를 자바스크립트 엔진에게 알린다.
- 선언이 된적이 있느냐 없느냐를 기억한다.
- 스코프는 자료구조(실행 컨텍스트의 렉시컬 환경)이다. 개념적인 존재 x
- 변수도 사실 객체처럼 자료구조(렉시컬 환경)에 저장된다.
- 함수 이름은 재귀 또는 디버깅으로 함수 내부에서 사용
- 선언문은 함수 식별자를 이름과 똑같이 만듬
- 함수 객체 + () 호출 연산자로 함수 실행, 함수 호출문은 제어문이다.
- 함수 내부의 문들은 호출 이전에 평가되지 않는다. lazy는 긍정
- 삭별자를 현재 실행중인 실행 컨텍스트에서 먼저 찾고 상위 스코프를 타고 검색
- 함수가 정의 될 때 내부 슬롯에 상위 스코프가 결정된다.
- 렉시컬 스코프가 클로저 그 자체이다.
- 스코프가 단방향인 이유는 없는 값을 찾을 때 무한 탐색을 하기 때문
- 소스코드? 엔진이 실행되기 전단계의 코드 === 문자열
- 인터프리터가 파싱하여 앱스트렉트신텍스트리(AST) 구조로 만들고 그걸로 파싱
  ([https://astexplorer.net/](https://astexplorer.net/))
- 객체라는 것은 속성들의 집합
- 상상속의 고양이는 클래스 눈 앞의 고양이는 인스턴스 ㅋㅋㅋㅋ
- 추상화라는 개념을 도입하여 개념에 대한 속성 중에 추려낸다.
- 부모를 상속받고, 정보 은닉 등 캡슐화
- 프로퍼티와 어트리뷰트는 조금 다른 개념, 속성으로 통칭하면 헷갈린다.
- css → 선택자 + 어트리뷰트 = 룰셋
- 자바스크립트는 객체 지향 프로그래밍이 위험할 수 있다.
- 패러다임에 대한 고민을 해 볼 필요가 있다.
- 프로퍼티는 상태인 값과 동작인 메서드를 포함할 수 있다.
- 자바스크립트의 객체의 프로퍼티도 객체로 구현된다(프로퍼티 어트리뷰트)
- 자바스크립트는 내부 슬롯과 내부 메서드를 가지고 있다.
- 폐지라는 개념은 지금도 존재하지만 쓰면 안된다는 의미( 하위 호환성으로 남겨둠 )
- 가변인자함수를 위해 arguments 객체를 제공한다.
- arguments는 정확한 사양이 없어 환경마다 다르게 구현되어 있을 수 있다.
- 프로퍼티 키가 문자열인 숫자 인덱스, length 속성이 있어야한다.
- 윈도우 콘솔에 찐한 프로퍼티는 열거 가능, 연한것은 열거 불가능 (프로퍼티 어트리뷰트)
- 순서가 있으면 순회(순열), 순서 상관 없으면 열거(객체 : 이름이 중요)
- 이뉴머러블이 false인 값들은 내부적으로 사용하는 목적이 강하다. 사용자가 알 필요 없는 것들
- 유사 배열 객체는 설계 미스로 인한 탄생?으로 추측
- 객체가 배열과 다른점 → 메서드를 정의할 수 있다.
- 배열 메서드가 잘 정의되어 있어 유사 배열 객체의 장점을 살릴 수 없어 안쓴다.
- rest 파라미터를 통해 배열 메서드를 사용하여 활용 시 가독성 좋음
- querySelectorAll ⇒ 유사 배열 객체로 반환, 배열로 변환하여 코딩이 좋은 코딩
- 생성자 함수의 사용 이유는 동일한 프로퍼티를 가진 객체를 반복해서 만들 때 유용해서
- this에는 할당이 불가능하다. 식별자와 값을 묶는 것이 바인딩
- 상속이 아니여도 조합으로 외부에 선언한 함수를 인스턴스의 공통 메서드로 줄 수 있다.
- 함수는 그 자체로는 어떻게 호출될지 모른다. this는 함수 호출 방식에 따라 결정된다.
- 생성자 함수가 만들어낼 인스턴스들에 대한 프로토타입이 생성자함수.prototype
- new 키워드로 만들어낸 객체를 통상적으로 인스턴스라고 한다.
- 프로퍼티는 대부분 인스턴스가, 메서드는 대부분 프로토타입이 가진다.
- 식별자는 스코프 체인, 프로퍼티는 프로토타입 체인에서 찾는다.
- 프로퍼티 키는 식별자 명명 규칙을 준수하지 않아도 된다. (식별자와의 차이)

# 🤯 하루을 마치며…

오늘 수업부턴 확실히 조금씩 내용이 어려워지고 있다는 느낌이 들었다. 수업을 통해 렉시컬 스코프에 대한 풀리지 않았던 개념에 대해 조금 더 깊게 이해할 수 있었다. 또 유사 배열 객체의 존재했던 이유와 arguments의 변화 과정 등 자바스크립트의 등장 이후 변화해가는 사양에 따라 달라지는 내부 알고리즘들에 대한 이해도 할 수 있었다. 또 가장 신선했던 것은 내부 공통 메서드에 대해 상속의 방법밖에 없다고 생각했지만 외부에 선언한 함수를 값으로 주는 조합의 방식으로도 프로그래밍을 할 수 있다는 것에 대해 애초에 생각해본 적도 없는 개념에 대해 알 수 있었다. 자바스크립트가 지향하는 패러다임에 대한 이해가 필요할 것 같아 오늘은 그 부분에 대해 마저 정리해 볼 생각이다! 남은 시간동안 책의 내용을 잘 습득할 수 있도록 반복을 많이 해야겠다고 생각했다.
