# 📖 오늘의 학습

## ES6 함수의 추가 기능

### 함수의 구분

> 기존의 함수는 호출 방식에 따라 다양하게 사용되어 실수를 유발할 수 있고 성능 면에서도 손해가 있다.

이러한 문제를 해결하기 위해 ES6는 함수를 사용 목적에 따라 세 가지 종류로 구분한다.

constructor, prototype, super, arguments 의 유무로 구분

- 일반 함수 → constructor, prototype, arguments
- 메서드 → super, arguments
- 화살표함수 → x

### 메서드

> ES6이후 메서드에 대한 정의가 명확하게 규정되었다. ES6에 추가된 축약 표현으로 정의된 함수만을 의미함

축약 메서드는 non-constructor이므로 new 키워드와 함께 생성자 함수로 호출할 수 없다.

인스턴스를 생성할 수 없으므로 prototype 프로퍼티가 없고 프로토타입도 생성하지 않는다.

표준 빌트인 객체가 제공하는 프로토타입 메서드와 정적 메서드는 모두 non-constructor이다.

자신을 바인딩한 객체를 가리키는 내부 슬롯 [[homeObject]]를 갖는다. 이를 통해 super 키워드를 사용한다.

### 화살표 함수

> 화살표 함수는 ⇒를 이용해 간략하게 정의할 수 있고, 동작도 기존 함수보다 간략하다. 특히 화살표 함수는 this가 콜백 함수 내부에서 전역 객체를 가리키는 문제를 해결하기 위한 방법으로 유용하다.

- 화살표 함수의 정의
  화살표 함수는 선언문으로 정의할 수 없고 표현식으로 정의해야 한다.
  함수 몸체가 하나의 표현식인 문이라면 중괄호를 생략할 수 있다.
  객체 리터럴을 반환할 경우 () 소괄호를 이용해 감싸주어야 한다.
  화살표 함수도 즉시 실행 함수로 사용이 가능하다.
- 화살표 함수와 일반 함수의 차이
  화살표 함수는 인스턴스를 생성할 수 없는 non-constructor다.
  중복된 매개변수 이름을 선언할 수 없다.
  함수 자체의 this, arguments, super, [new.target](http://new.target) 바인딩을 갖지 않는다.
- this
  화살표 함수가 일반 함수와 구별되는 가장 큰 특징이 바로 this다.
  콜백 함수에 일반 함수를 사용할 경우 콜백 함수 내부의 this와 외부 함수의 this가 다른 문제가 발생한다.
  > 화살표 함수는 함수 자체의 this 바인딩을 갖지 않는다. 따라서 함수 내부의 this는 상위 스코프의 this를 그대로 참조한다. 이를 lexical this라고 한다.

### Rest 파라미터

> Rest 파라미터는 매개변수 이름 앞에 …을 붙여 정의한 매개변수를 의미한다. 함수에 전달된 인수들의 목록을 배열로 전달받는다.

일반 매개변수와 함께 사용 가능하고 Rest 파라미터의 이름처럼 나머지가 들어오므로 제일 뒤에 선언되어야 한다.

함수 내부의 length 프로퍼티에 영향을 주지 않는다.

arguments 객체 또한 인수를 저장하지만 유사 배열 객체이므로 배열 메서드를 바로 사용할 수 없고, 화살표 함수 내부에는 생성되지 않으므로 Rest 파라미터를 사용하는 것이 권장된다.

### 매개변수 기본값

> 함수를 호출할 때 인수의 개수를 체크하지 않으므로 의도치 않은 결과가 생길 수 있다. 따라서 예측하지 못한결과를 방지하기 위해 방어 코드가 필요하다. ES6에서 도입된 매개변수 기본값을 사용하면 인수 체크 및 초기화를 간소화할 수 있다.

## 배열

### 배열이란?

> 배열은 여러 개의 값을 **순차적**으로 나열한 자료구조이다. 사용빈도가 가장 높다.

배열은 일반 객체와 달리 length와 index를 가지며 값에 순서가 있고 length 프로퍼티를 갖는다.

### 자바스크립트 배열은 배열이 아니다

자료구조에서 말하는 배열은 동일한 크기의 메모리 공간에 빈틈없이 연속적으로 나열된 자료구조를 말한다. 즉 배열의 요소는 하나의 타입으로 통일되어 있으며 서로 연속적으로 인접해 있다. 이러한 배열을 밀집 배열이라고 한다

> 자바스크립트의 배열은 일반적인 배열과는 달리 메모리 크기가 동일하지 않고 연속적으로 이루어져 있지 않을 수 있는 희소 배열이다. 이처럼 자바스크립트의 배열은 엄밀히 말해 일반적인 배열의 동작을 흉내 낸 특수한 객체다.

- 일반적인 배열과 자바스크립트 배열의 장단점
  일반 배열 → 인덱스로 요소에 빠르게 접근할 수 있다. 요소 추가 삭제의 경우는 효율적이지 않다.
  자바스크립트 배열 → 인덱스로 접근하는 경우 일반 배열보다 느림, 요소 추가 삭제는 빠름

자바스크립트 배열은 이런 구조적 단점을 보완하기 위해 일반 객체와 구별하여 좀 더 배열같이 동작하도록 최적화하여 구현하였다. 성능 테스트 시 일반 객체보다 약 2배정도 빠르다.

### length 프로퍼티와 희소 배열

> length 프로퍼티는 요소의 개수, 즉 배열의 길이를 나타내는 0 이상의 정수 값을 갖는다.

배열에 요소를 추가하거나 삭제할 경우 자동으로 갱신된다.

임의의 숫자 값을 명시적으로 할당할 경우 현재 값보다 작은 값을 할당하면 배열의 길이가 줄어들고, 큰 숫자를 할당하면 length 프로퍼티의 값은 변경되지만 실제로 배열의 길이가 늘어나지는 않는다.

값이 비어있는 요소를 위해 메모리 공간을 확보하지 않으며 빈 요소를 만들지도 않는다.

이처럼 요소가 연속적이지 않고 일부가 비어있는 배열을 희소 배열이라고 한다.

희소 배열의 length는 실제 요소 개수보다 언제나 크다!

같은 타입의 요소를 연속적으로 위치시키는 것이 최선이고, 엔진은 이 경우 일반적인 의미의 배열처럼 동작한다고 알려져 있다.

### 배열 생성

1. 배열 리터럴

   배열 리터럴에 요소를 생략하면 희소 배열이 생성된다.

2. Array 생성자 함수

   인수가 1개이고 숫자인 경우 length 프로퍼티가 인수인 배열을 만든다.

   음수는 에러가 발생하고 최대로 가질 수 있는 범위가 존재한다.

   인수가 없는 경우 빈 배열을 생성한다.

   인수가 2 이상이거나 숫자가 아닌 경우 인수를 요소로 갖는 배열을 생성한다.

3. Array.of

   ES6에서 도입된 메서드로 전달된 인수를 요소로 갖는 배열을 생성한다.

4. Array.from

   ES6에서 도입된 메서드로 유사 배열 객체 또는 이터러블 객체를 인수로 전달받아 배열로 변환하여 반환한다.

   두번째 인수로 받는 콜백 함수를 통해 값을 만들면서 요소를 채울 수 있다.

   ```jsx
   Array.from({length:3}),(_,i) => i); // [0,1,2];
   ```

### 배열 요소의 참조

[1] 과 같이 인덱스로 접근하며 없는 인덱스에 접근할 경우 undefined를 반환한다.

### 배열 요소의 추가와 갱신

동적으로 추가가 가능하며 length보다 큰 인덱스로 추가할 경우 희소 배열이 된다.

인덱스 외의 값을 사용하면 프로퍼티가 추가된다. 프로퍼티는 length 속성에 영향을 주지 않는다.

### 배열 요소의 삭제

배열은 사실 객체이기 때문에 delete 연산자를 사용할 수 있다. 하지만 사용 시 희소 배열이 되므로 특정 요소를 완전히 삭제하려면 splice 메서드를 사용한다.

### 배열 메서드

> 배열 메서드에는 원본 배열을 직접 변경하는 메서드와 새로운 배열을 생성하여 반환하는 메서드가 있다. 원본 배열을 변경하는 경우 부수 효과가 있으므로 사용에 주의해야 하고 되도록 직접 변경하지 않는 메서드를 사용하는 것이 권장된다.

빌트인 Array 객체가 제공하는 다양한 메서드는 책과 mdn을 통해 확인하자!!

# 🤯 하루을 마치며…

오늘은 ES6에 추가된 내용들과 빌트인 객체인 Array에 대한 러버덕을 진행헀다. 강사님의 말씀대로 바뀌어가는 사양들을 보며 바뀌어가는 프로그래밍 패러다임이 조금씩 이해되는 부분이 있는 것 같다. 자바스크립트의 실수를 발생시킬 수 있는 느슨한 문법들을 해결하기 위한 문법들이 추가되고, 하나의 기능을 위해 내부의 기능들을 간소화해가고 있다는 느낌이 들었다. 특히 화살표 함수의 경우 this의 고질적인 문제를 해결하기 위해 내부의 this를 없애 상위와 this를 일치시켜주는 것을 조금이나마 이해할 수 있었던 것 같다. 오늘과 내일 보게될 빌트인 객체들의 메서드들도 여러번 사용해보고 숙지하여 코딩 스킬이 발전할 수 있도록 반복해서 읽어야겠다고 생각했다.
