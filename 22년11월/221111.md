# 📖 React

### 수업 정리

- Ref 참조 객체는 변경되어도 리렌더링이 발생하지 않는다.
- Ref의 용도는 요소에 접근 또는 변경되어도 리렌더링이 발생하지 않는 값을 기억하기 위해
- forwardRef를 사용하여 부모에서 생성한 Ref를 전달할 수 있다.
- 클래스가 주를 이룰 때 리액트는 render-props-pattern과 고차 컴포넌트를 많이 사용하였다.
- 클래스 컴포넌트의 치명적인 단점은 컴포넌트가 가진 내부 로직이 캡슐화되어 재사용을 할 수 없다.
- 이를 사용하기 위해 고차 컴포넌트를 사용했지만 이 또한 문제를 발생시켜 hooks가 등장하게 되었다.
- forwardRef를 사용하여 바깥 컴포넌트에서 자식 컴포넌트의 요소에 접근할 수 있게 만들 수 있다.
- 꼭 forwardRef를 사용하지 않고 다른 프로퍼티로 ref를 넘겨주어도 사용 가능하다.
- cra에서 cors를 허용하기 위해 개발단계에서는 클라이언트의 package.json에 proxy 설정이 가능하다.
- 돔 기반 서드파티 라이브러리를 어떻게 하면 리액트에 적용시킬 수 있는가? 라이프 사이클 메서드를 사용하여 사이드 이펙트를 처리해주면 사용할 수 있다.
- 이벤트를 구독만 하고 취소하지 않으면 이벤트가 남아있는 문제가 발생하여 성능 저하가 유발된다.
- 포털은 돔트리의 위치와 상관없이 리액트 트리에 포함되어 있다.
- 모달 다이얼로그가 떠있을 때에는 포커스가 다이얼로그 요소 외부로 빠져나가면 안된다.
- 모달 다이얼로그가 닫히면 해당 다이얼로그를 열었던 오프너에게 포커스가 가야한다.
- focusable과 tabbable의 차이? 포커스가 가능한지, 탭키로 이동 가능한지의 차이
- 시각적으로 표현되지 않는데 리더가 읽어야한다면 aria-label, 표현되어 있는데 제목 요소가 아닌 경우 aria-labelledby를 사용하여 제목임을 알려야함
- 컴파운드 컴포넌트를 사용할 경우 종속된 컴포넌트로 묶을 수 있다.

### 강의 정리

- useEffect의 콜백은 async 함수로 프로미스를 반환하지 않아야 한다. 리턴 값이 없거나 언마운트 시 호출 되어질 함수를 반환해야 하므로 경고 메세지를 띄우게 된다.
- 커스텀 훅을 사용하여 컴포넌트 내부의 반복적인 로직을 재사용 할 수 있다.
- swr 라이브러리의 useSWR은 비동기 처리를 할 때 키 값을 넣어주면 해당 요청에 대한 응답을 캐싱해두어 리렌더링 시 다시 요청하지 않고 캐싱된 값을 사용하게 된다. 상태 관리를 위한 라이브러리이다.
- 전역 상태는 주로 로그인한 유저 정보나 페이지의 테마 등을 가지고 모든 컴포넌트에서 접근 가능한 상태를 말한다.
- Context API를 활용하여 props로 전달하지 않아도 자식 컴포넌트가 context에 접근할 수 있게 해준다.
- createContext로 Context를 생성하고 Context.Provider의 value로 전역으로 사용할 값을 지정할 수 있다. 하위 요소는 useContext를 통해 가져올 수 있다.
- context를 구독하는 모든 컴포넌트는 provider의 value가 바뀔 때마다 리렌더링이 발생한다.
- useReducer를 사용하면 useState의 병합 현상이 발생하지 않는다. 다음 state가 이전 state에 의존성을 가질 경우 useReducer가 선호된다.
- useReducer를 사용하면 상태를 변경하는 비지니스 로직을 컴포넌트와 분리해서 관리할 수 있게 된다.
