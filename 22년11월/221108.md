# 📖 React

### 수업 정리

- 클라이언트에 접근 가능한 환경변수는 $로 변수 사용이 가능하다.

```
API_KEY=sfsdfksdfkskasdfas

REACT_APP_API_KEY=$API_KEY
```

- aria-, data- 이 두가지는 카멜케이스가 아닌 - 사용을 허용한다.
- src폴더 안의 svg 파일은 svgr을 사용해 svg 파일을 컴포넌트로 사용할 수 있다.
- TTD는 디자이너와 협업과정, 비주얼 영역에 대한 테스트가 어렵다. 클래스 기반인 css 테스트가 불가능하다.
- jest의 사용자 정의 matcher 함수를 정의하고 사용할 수 있다.
- test에서 요소를 가져오기 위한 방법 중 data-testid를 부여하여 렌더 된 테스트 요소를 가져올 수 있다.
- getByRole로 요소를 가져오기 위해서는 개발자 도구의 접근성 탭에 정의된 Role 속성이 있어야 한다.
- 상태가 없는 컴포넌트일 경우 왜 클래스를 안쓰고 함수를 사용하는가? → this 사용, render 정의 등 번들링의 결과가 낭비되기 때문에 함수로 정의한다.
- class는 인스턴스가 생성되어 this를 가지고 함수는 인스턴스를 만들지 않기 때문에 this를 사용할 수 없다.
- 클래스는 내부 로직의 재사용이 쉽지 않기때문에 hooks를 사용한 함수 컴포넌트가 트렌드가 되었다.
- props, state, 강제 업데이트 세가지 방법이 리렌더링을 수행한다.
- JSX를 형제요소로 반환할 경우 배열로 가능하지만 key 값이 필요해지므로 fragment나 <> 단축으로 사용
- props는 읽기 전용이다. 하위 컴포넌트에서 props를 변경하려고 하면 에러를 발생시킨다.
- props의 값을 바꾸고 싶은 경우 state에 할당하여 사용할 수 있다.
- state를 직접 수정하면 안되고 setState를 사용하여 업데이트 해야 리렌더링이 발생한다.
- 클래스 필드 정의가 표준이 되면서 class 컴포넌트를 사용할 경우 constructor 대신 클래스필드에 state를 정의할 수 있게 되었다.
- 파생 상태는 본인이 가진 상태가 아닌 props 등 다른 곳으로부터 파생되어진 상태를 의미한다.
- 16버전까진 root에 이벤트가 등록되었으나 17버전부터 리액트 루트 컨테이너에 바인딩이 된다.
- createRoot로 만들어낸 루트 컨테이너에 이벤트 바인딩

### 클래스 컴포넌트

- 클래스의 setState API 의 인수는 객체 또는 콜백 함수를 줄 수 있다.
- 리렌더링이 이전 상태 값을 확인하여 변경되었을 때만 발생하도록 해야 성능도 챙길 수 있다.
- JSX를 통해 이벤트를 바인딩하기 때문에 핸들러에 this를 바인딩해주어야만 동작한다.
- 콜백 함수를 사용하면 인수로 이전 상태를 받고 new state를 return하는 구조로 사용된다. 디스트럭처링을 활용하여 이전 상태를 가져와 여러 상태를 한번에 처리하기 좋기 때문에 사용
- setState는 병합되어 비동기적으로 처리하기 때문에 한 번만 리렌더링이 발생한다.
- 두번째 인자에 콜백을 통하여 상태 업데이트 이후 시점을 보장한다.
- 라이프 사이클 메서드를 이용하여 불필요한 리렌더링을 방지할 수 있다. 성능 저하 방지
- 리액트의 라이프 사이클 메서드는 충돌을 방지하기 위해 일부러 메서드 이름이 복잡하다.
- StrictMode 개발상에서만 적용되고, 개발 과정의 문제진단을 위해 2번씩 실행시킨다. 빌드하면 사라짐ㅋ

### 강의 정리

- JSX는 React.createElement의 문법적 설탕으로 컴포넌트 작성이 용이하고 가독성을 높여준다.
- JSX는 HTML과 유사한 문법을 제공하여 JS에 HTML를 표현하기 좋다.
- 컴포넌트의 재사용을 위해 props를 활용할 수 있다.
- props는 기본적으로 children을 가지고, 컴포넌트의 자식으로 넘어온 값을 가진다.
- props로 값을 넘길때 값이 없이 넘길 경우 디폴트 값으로 true가 넘어온다.
- 객체를 디스트럭처링으로 풀어주게 되면 프로퍼티들이 props로 넘어가게 된다.
- 컴포넌트 내부의 상태값이 변화함에 따라 다시 함수가 호출되게 하기 위해 hook를 사용한다.
- 리액트는 이전 상태와 현재 상태를 비교할 때 얕은 비교를 하기 때문에 불변성을 지키지 않고 값을 직접 변경한 경우 state가 변경되었다고 인지하지 못한다.
- setState는 비동기로 실행되고 객체가 병합되기 때문에 의도한대로 동작하지 않을 수 있다.
- setState의 인수를 콜백 함수로 줄 경우 원하는대로 동작하게 만들 수 있다.

# 🤯 하루를 마치며…

오늘은 상태가 없는 stateless 컴포넌트를 만들고 jest로 테스트하여 완성된 컴포넌트를 렌더링하여 보여지는 것에 대한 테스트까지 진행하였다. A11yHidden 컴포넌트를 만들어보며 어떤 방식으로 컴포넌트를 설계해야 재사용성이 좋아질지에 대한 고민을 할 수 있었고, props를 활용하여 원하는 태그로 렌더링되게 한다던지 다양한 속성들을 사용하여 컴포넌트를 제어하는 것에 대해 배울 수 있었다. 또 jest의 목 함수를 만들어 테스트하거나 matcher 함수들을 활용하여 테스트를 할 때 테스트로 그려낸 요소를 가져올 때 data-testid를 활용하여 쉽게 가져올 수 있다는 것을 알 수 있었다. 상태를 가지는 컨테이너 컴포넌트에 대해서도 조금 배웠는데 컴포넌트는 props나 state가 변경되었을 때 리렌더링이 발생하고, 상태가 변하지 않았을 때 불필요한 렌더링이 되지 않게 하기위해 라이프싸이클 메서드가 있고 이를 활용해 성능을 향상시킬 수 있다는 것을 배웠다. 자바스크립트의 내용을 앞전에 깊게 다루어 보고 듣는 리액트 수업이라 확실히 아무것도 모르는 백지 상태로 들었을 때보다 코드들이 어떻게 동작하는지 예상해보며 이해하려고 노력할 수 있게 되었다. 수업의 속도가 내가 체감하기엔 조금 빠른 감이 있지만 최대한 소화하고 다음 수업을 듣기 위해 반복해서 학습해야겠다.
