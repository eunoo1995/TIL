# 📖 딥다이브 복습 러버덕

## 이벤트

### 이벤트 드리븐 프로그래밍

> 브라우저는 특정 사건이 발생하면 이를 감지하여 이벤트를 발생시킨다. 이때 호출될 함수를 이벤트 핸들러라고 하고, 이벤트가 발생했을 때 브라우저에게 이벤트 핸들러의 호출을 위임하는 것을 이벤트 핸들러 등록이라고 한다. 이처럼 이벤트와 그에 대응하는 이벤트 핸들러를 통해 사용자와 어플리케이션은 상호작용 할 수 있다. 프로그램의 흐름을 이벤트 중심으로 제어하는 프로그래밍 방식을 이벤트 드리븐 프로그래밍이라 한다.

### 이벤트 타입

> 이벤트 타입은 이벤트의 종류를 나타내는 문자열이다. 이벤트 타입은 약 200여 가지가 있다.

### 이벤트 핸들러 등록

> 브라우저에게 이벤트 핸들러를 호출을 위임하는 것을 이벤트 핸들러 등록이라 하고 3가지 방법이 있다.

- 이벤트 핸들러 어트리뷰트 방식
  HTML 요소의 어트리뷰트 중에는 이벤트에 대응하는 이벤트 핸들러 어트리뷰트가 있다.
  이벤트 핸들러 어트리뷰트 값으로 함수 호출문 등 문을 할당하면 이벤트 핸들러가 등록된다.
  주의할 점은 함수 참조가 아닌 문을 할당하는 것, 암묵적으로 생성될 이벤트 핸들러의 함수 몸체를 의미
- 이벤트 핸들러 프로퍼티 방식
  DOM 노드 객체는 이벤트에 대응하는 이벤트 핸들러 프로퍼티를 가지고 있다.
  이벤트를 발생시킬 객체인 이벤트 타겟 , 이벤트 종류인 이벤트 타입, 그리고 이벤트 핸들러를 지정해야 한다.
  등록한 이벤트를 제거하려면 프로퍼티에 임의로 null 값을 넣어주어야 한다.
- addEventListener 메서드 방식
  이벤트타켓.addEventListener(’이벤트 타입',이벤트 핸들러,[캡쳐링 사용 여부]);
  세번째 인수로 넘겨주는 boolean 값은 이벤트 전파 캡쳐링 사용 여부를 지정한다.
  하나 이상의 이벤트 핸들러를 등록할 수 있다. 등록된 순서대로 호출된다.
  등록한 이벤트를 제거하고 싶은 경우 removeEventListener 메서드를 사용한다.
  등록 당시의 인수와 동일한 인수를 주어야만 이벤트가 제거된다.

### 이벤트 객체

> 이벤트가 발생하면 이벤트에 관련한 정보를 담고있는 이벤트 객체가 동적으로 생성되고 이 객체는 이벤트 핸들러의 첫번째 인수로 전달된다.

- 이벤트 핸들러 어트리뷰트 방식으로 등록한 이벤트 핸들러는 암묵적으로 생성될 때 암묵적으로 생성되는 첫번째 매개변수인 event에 이벤트 객체가 담기므로 어트리뷰트 값 내부에서 반드시 event로만 객체를 전달받을 수 있다.
- 이벤트 객체는 다양한 이벤트 종류의 생성자 함수에 의해 생성된다. 그리고 생성된 이벤트 객체는 프로토타입 체인의 일원이 된다.
- 이벤트 인터페이스 즉 Event.prototype에 정의되어 있는 이벤트 관련 프로퍼티는 모든 이벤트 객체에 상속되는 공통 프로퍼티이다.

### 이벤트 전파

> DOM 트리 상의 요소 노드에서 발생한 이벤트는 발생시킨 이벤트 타겟을 중심으로 DOM 트리를 통해 캡쳐링 단계, 타깃 단계, 버블링 단계로 전파된다. 이벤트는 이벤트 타깃은 물론 상위 DOM 요소에서도 캐치할 수 있다.

### 이벤트 위임

> 이벤트 전파를 통해 상위 DOM 요소에서도 이벤트를 캐치할 수 있다.이를 통해 하위 DOM 요소에 각각 이벤트를 등록하는 것이 아닌 상위 DOM 요소에 한번만 등록하는 방법을 이벤트 위임이라고 한다.

### DOM 요소의 기본 동작 조작

- 이벤트 객체.preventDefault() 메서드를 통해 요소의 기본 동작을 중단시킨다.
- 이벤트 객체.stopPropagation() 메서드를 통해 이벤트 전파를 중단시킨다.

# 🤯 하루를 마치며…

### 9.CBD-SPA-library

걱정했던 것 처럼 9번 미션은 생각보다 더 난관이었다. 어떤 방향으로 진행하는 것이 맞는지부터가 막막했다. 팀원이 잘 이끌어준 덕분에 방향을 잡고 차근차근 진행할 수 있었다. 또한 배려를 많이 해주고 수긍해주어 한결 더 수월하게 진행할 수 있었다. 제일 어려웠던 부분은 재귀를 돌며 가상 돔을 실제 돔에 변경되어진 부분만 반영하게 해주는 diff 알고리즘을 구현하는 것이다. 계속 고민을 하며 알고리즘 함수를 만들어내고 동작시켰을 때 완벽하게 동작하지 않아 여러 시행착오를 겪으며 계속 수정했고, 책에서 공부했던 어트리뷰트와 프로퍼티의 차이를 경험하게 되었다. checked 어트리뷰트 노드는 초기의 값만을 저장하고 있고, 화면에 보여지는 상태를 가지고 있는 것은 프로퍼티라는 부분을 다시 기억할 수 있었다. 그렇게 알고리즘 내부에서 어트리뷰트, 프로퍼티, 요소, 텍스트를 비교하여 바뀌어진 부분에 대해서만 리렌더링을 하는 방법이 구현하고 나서 보니 신기했다. 기능을 어느정도 완성한 후 라이브러리의 관점으로 로직을 분리해내어 재사용이 가능한 파일을 분리해내는 과정에서 강사님의 피드백이 내가 나눈 기준과 많이 상이해서 어떻게 수정해볼지에 대해서 고민해보게 되었고, 클래스를 활용하여 사용자가 라이브러리를 사용할 때 작성할 내용이 최소화될 수 있도록 공통된 부분을 뽑아내는 것에 대해 고민하고 있다. 내일은 오늘 완성한 방법을 남겨두고 강사님이 주신 피드백을 활용하여 클래스 기반 컴포넌트로 구현해보아야겠다!
